<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jeffery&#39;s Blog</title>
  
  <subtitle>为而不争</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jefferyfan.com/"/>
  <updated>2019-11-22T15:55:51.193Z</updated>
  <id>http://jefferyfan.com/</id>
  
  <author>
    <name>Jeffery Fan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Objective-C 动态之 Non-fragile ivar</title>
    <link href="http://jefferyfan.com/programing/iOS/non-fragile-ivar/"/>
    <id>http://jefferyfan.com/programing/iOS/non-fragile-ivar/</id>
    <published>2019-11-22T07:29:21.000Z</published>
    <updated>2019-11-22T15:55:51.193Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C 是一门动态语言。所谓动态，在于消息发送和转发，在于 Method Swizzling，同时也在于 Non-fragile ivar。之前有一篇文章简单介绍过消息发送和转发（<a href="/2016/01/24/programing/iOS/tutorial/02MethodResolve/">iOS教程（二）消息发送</a>），这一篇主要介绍下 Non-fragile ivar 特性及其实现方式。</p><h2 id="什么是-ivar-？"><a href="#什么是-ivar-？" class="headerlink" title="什么是 ivar ？"></a>什么是 ivar ？</h2><p>ivar（instance variable）就是类成员变量。一般情况下，property 都会自动生成一个成员变量。</p><p>假设有一个 MyObject 类，有 array 和 color 两个成员变量， MyObject 实例的内存结构如下：<br><img src="/images/ivar-layout.jpeg" alt="ivar-layout"></p><p>如果要获取 color 的值，self 指针加上偏移量，再解引用就可以了，这也是 runtime 获取成员变量的方式。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIColor</span> *color = *(<span class="built_in">UIColor</span> *)((<span class="keyword">char</span> *)<span class="keyword">self</span> + <span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>当然，runtime 的逻辑比这复杂，例如 atomic 加锁等。</p><h2 id="什么是-Non-fragile-ivar-？"><a href="#什么是-Non-fragile-ivar-？" class="headerlink" title="什么是 Non-fragile ivar ？"></a>什么是 Non-fragile ivar ？</h2><p>fragile 的含义是脆弱的，Non-fragile ivar 解决的是 fragile ivar 的问题。</p><h4 id="fragile-ivar-问题"><a href="#fragile-ivar-问题" class="headerlink" title="fragile ivar 问题"></a>fragile ivar 问题</h4><p>在 32 位的 Mac 上，假定有一个 NSCustomView 继承自 NSView，NSCustomView 有两个成员变量。（至于为什么是 32 位的 Mac，接下来会介绍。）</p><a id="more"></a><p><img src="/images/custom-view.jpeg" alt="NSCustomView"></p><p>我们可以看到，NSCustomView 给 NSView 的成员变量 color 预留了内存空间。在创建 NSCustomView 的实例时，总是申请 12 字节的内存给 isa、color 和 array。</p><p>如果苹果希望给 NSView 添加字体配置功能，并引入一个新的成员变量 font，NSView 成员变量增加至两个。在不重新编译的情况下，MyCustomView 只为 NSView 申请了一个成员变量的空间。</p><p><img src="/images/custom-view-fragiled.jpeg" alt="custom-view-fragiled"></p><p>显然，NSView 增加新功能后，NSCustomView 申请的内存空间不够用了，运行起来会造成不可预知的错误。究其原因，是因为子类所申请的内存空间数量在编译期已经确定了，NSView 改变之后需要重新编译 NSView 的所有子类，才能够有足够的内存空间来适应 NSView 的新功能。</p><p>当然，我们现在不再需要担心这个问题了。在 32 位的 Mac 上运行的是 Legacy Runtime，存在 fragile ivar 的问题，而 iPhone 以及 64 位 Mac 上运行的 runtime 是 Modern Runtime，已经解决了这个问题，具有 Non-fragile ivar 的特性。</p><p>在 Modern Runtime 下，NSCustomView 的内存结构如下：<br><img src="/images/custom-view-non-fragile.jpeg" alt="custom-view-non-fragile"></p><h4 id="Non-fragile-ivar"><a href="#Non-fragile-ivar" class="headerlink" title="Non-fragile ivar"></a>Non-fragile ivar</h4><p>在上面的例子中，NSCustomView 实例有两个变化点。</p><ol><li>创建实例所需内存由 12 字节增长到 16 字节</li><li>array 成员变量的 offset 由 8 变为 12</li></ol><p>很自然的想到，解决了以下两个问题，那么自然 fragile ivar 的问题也就解决了，也就有 Non-fragile ivar 的特性。</p><ol><li>申请实例内存数量可以动态调整。当父类变化时，需要动态修改申请内存的数量。</li><li>成员变量的 offset 可以动态调整。</li></ol><p>⚠️ 注意，这里所说的动态不是指运行时的动态，是指每次启动时动态调整。在当次 App 真正运行起来后，是不会动态调整的，这也是 OC 不支持运行时动态添加 ivar 的原因。</p><h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><p>为了探索 ivar 的底层实现，我们先创建 IvarDemo 类，继承自 IvarDemoBase。（IvarDemoBase 这个基类内没有逻辑，但 IvarDemoBase 是必须的，之后会解释为什么需要这个基类。）</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IvarDemo.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IvarDemoBase</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *baseName;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IvarDemo</span> : <span class="title">IvarDemoBase</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *demoName;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IvarDemo.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"IvarDemo.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">IvarDemoBase</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [_baseName release];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">IvarDemo</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [_demoName release];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h4 id="clang-rewrite-源码分析"><a href="#clang-rewrite-源码分析" class="headerlink" title="clang rewrite 源码分析"></a>clang rewrite 源码分析</h4><p>clang rewrite 是常规操作。通过 clang 命令，将 OC 代码转化 C++ 代码，看下具体实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -rewrite-objc -x objective-c -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk -fobjc-weak -fobjc-runtime=ios-13.2.2 IvarDemo.m</span><br></pre></td></tr></table></figure><p>得到的 IvarDemo.cpp 文件就是转化后的 C++ 代码。我们来看下其中关键的几处代码。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * _Nonnull _I_IvarDemo_demoName(IvarDemo * <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line"><span class="keyword">return</span> (*(<span class="built_in">NSString</span> * _Nonnull *)((<span class="keyword">char</span> *)<span class="keyword">self</span> + OBJC_IVAR_$_IvarDemo$_demoName)); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _I_IvarDemo_setDemoName_(IvarDemo * <span class="keyword">self</span>, SEL _cmd, <span class="built_in">NSString</span> * _Nonnull demoName) &#123;</span><br><span class="line">objc_setProperty (<span class="keyword">self</span>, _cmd, __OFFSETOFIVAR__(<span class="keyword">struct</span> IvarDemo, _demoName), (<span class="keyword">id</span>)demoName, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个函数是 demoName 属性的 getter 和 setter。</p><ul><li>getter 中的 offset 是从变量 <code>OBJC_IVAR_$_IvarDemo$_demoName</code> 中获取的</li><li>setter 中的 offset 是通过 <code>__OFFSETOFIVAR__</code> 宏计算得到，是编译期确定的常量数值。</li></ul><blockquote><p>⚠️ 注意，实际上 setter 中的 offset 也是从变量 <code>OBJC_IVAR_$_IvarDemo$_demoName</code> 中获取的，这里 clang 转化后的 setter 代码与实际情况不符合。后面我们可以从汇编代码中验证这一点。</p></blockquote><p>我们继续看一下 <code>OBJC_IVAR_$_IvarDemo$_demoName</code> 的定义。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> OBJC_IVAR_$_IvarDemo$_demoName __attribute__ ((used, section (<span class="string">"__DATA,__objc_ivar"</span>))) = __OFFSETOFIVAR__(<span class="keyword">struct</span> IvarDemo, _demoName);</span><br></pre></td></tr></table></figure><p>这里有两个信息点需要留意：</p><ol><li><code>OBJC_IVAR_$_IvarDemo$_demoName</code> 变量是一个全局变量。</li><li><code>OBJC_IVAR_$_IvarDemo$_demoName</code> 变量存储在 Mach-O 文件中的 <code>__DATA,__objc_ivar</code> section，之后可以利用 otool 命令来查看。</li></ol><p>那么可以猜测在 App 启动时，检查父类是否有变化，动态的修改这个全局变量，那么就可以达到「动态调整 offset」的目的。事实上，runtime 就是这么做的。</p><p>接下来我们继续通过汇编分析来证实我们的猜测，会比较繁琐，不想看的朋友可以直接跳过。</p><h4 id="调试汇编分析"><a href="#调试汇编分析" class="headerlink" title="调试汇编分析"></a>调试汇编分析</h4><p>先贴一下用于调试的代码。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    <span class="keyword">struct</span> FakeIvar &#123;</span><br><span class="line">        int32_t *offset;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *type;</span><br><span class="line">        uint32_t alignment_raw;</span><br><span class="line">        uint32_t size;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Ivar *ivarList = class_copyIvarList(<span class="keyword">self</span>, &amp;count);</span><br><span class="line">    assert(count &gt; <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">struct</span> FakeIvar *firstIvar = (<span class="keyword">struct</span> FakeIvar *)ivarList[<span class="number">0</span>];</span><br><span class="line">    intptr_t slide = _dyld_get_image_vmaddr_slide(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"ivar name: %s, offset ptr: %p, offset ptr in mach-o: %p"</span>, firstIvar-&gt;name, firstIvar-&gt;offset, (<span class="keyword">char</span> *)firstIvar-&gt;offset - slide);</span><br><span class="line">    </span><br><span class="line">    IvarDemo *demo = [[IvarDemo new] autorelease];</span><br><span class="line">    demo.demoName = <span class="string">@"Hello, Non-fragile ivar"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解释一下，FakeIvar 其实就是 Ivar 在 runtime 中结构。系统并没有暴露 Ivar 的实现，所以这里为了方便的取出 Ivar 中的数据，定义了一个一模一样的结构体。</p><p>其次，iOS 系统用了 ASLR (Address Space Layout Randomization)技术，这是一种安全机制。简单来说，mach-o 文件中的地址，与实际运行时获取到的内存地址，总是存在一个偏移量 slide。而且，每次启动这个偏移量都是会变化的。<code>_dyld_get_image_vmaddr_slide</code> 函数就是获取这个偏移量的。</p></blockquote><p>在最后一行代码中打一个调试断点，同时在 Xcode 中勾选 Debug -&gt; Debug Workflow -&gt; Always Show Disassembly。这样运行后，就可以看到运行时的汇编代码。</p><p>真机（iPhone XS）运行后，step into 一次就可以进入到 <code>setDemoName:</code> 的汇编代码中。<br><img src="/images/ivar-disassemblly.jpg" alt="ivar-disassemblly"></p><p><code>setDemoName:</code> 最终是调用到 <code>objc_setProperty_nonatomic_copy</code> 函数中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setProperty_nonatomic_copy</span><span class="params">(id self, SEL _cmd, id newValue, <span class="keyword">ptrdiff_t</span> offset)</span> </span>&#123;</span><br><span class="line">    reallySetProperty(self, _cmd, newValue, offset, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>objc_setProperty_nonatomic_copy</code> 函数中的第 4 个参数传递的是 ivar 的 offset。</p><blockquote><p>在 ARM64 架构的函数调用中，x0 ~ x7 寄存器用来传递调用参数，x0是第一参数，依次类推。同时 x0 寄存器也用于传递返回值。</p></blockquote><p>断点断到 <code>bl     0x10298e470</code> 这一行，通过 <code>register</code> 命令来看下寄存器中的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">register <span class="built_in">read</span> x3</span><br><span class="line">// x3 = 0x0000000000000010</span><br></pre></td></tr></table></figure><p>也就是说，offset 传递的是 16，跟我们的理解是一致的（isa 和 _baseName 分别占 8 个字节）。</p><p>再往回看汇编源码，可以看到 <code>ldrsw  x3, [x8]</code>，这一句可以简单理解为 <code>x3 = *x8</code>，也就是 x8 解引用后赋值给 x3。</p><p><img src="/images/15744183679980.jpg" alt="-w779"></p><p>再运行一次，断点断到 <code>ldrsw  x3, [x8]</code> 这句，看下寄存器 x8 的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// ivar name: _demoName</span><br><span class="line">// offset ptr: 0x104f71644</span><br><span class="line">// offset ptr in mach-o: 0x10000d644</span><br><span class="line"></span><br><span class="line">register read x8</span><br><span class="line">// x8 = 0x0000000104f71644  IvarDemo`IvarDemo._demoName</span><br></pre></td></tr></table></figure><p>这一步可以很明显的看到，寄存器 x8 中存的地址跟 ivar-&gt;offset 中是一样的，在 mach-o 文件中的地址是 <code>0x10000d644</code>。</p><p>最后一步，用 otool 命令来看下 <code>__DATA,__objc_ivar</code> 中的数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">otool -s __DATA __objc_ivar IvarDemo</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">IvarDemo:</span><br><span class="line">Contents of (__DATA,__objc_ivar) section</span><br><span class="line">000000010000d64000000008 00000010 00000008</span><br></pre></td></tr></table></figure><p>上一步得到的<code>0x10000d644</code>地址就对应 <code>00000010</code> 这一段数据，也就是 16。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在代码中访问成员变量，或者是属性 property 的 setter / getter 中，都是通过一个全局变量来获取 offset 的，runtime 中维护的 ivar-&gt;offset 也是指向这个全局变量的。</p><p>全局变量和成员变量是一对一的。但苹果对此做了一个优化，如果一个对象直接继承自 NSObject，访问成员变量时 offset 是编译期直接确定的（hardcode），省去了全局变量解引用这一步。这就是前面说 IvarDemoBase 是必需的原因。直接继承自 NSObject，我们就看不到前面所分析的汇编逻辑了。</p><p>这一逻辑为实现「动态调整 offset」的目标奠定了基础，只需要在 App 启动时动态的计算这些 offset。</p><h4 id="Runtime-源码"><a href="#Runtime-源码" class="headerlink" title="Runtime 源码"></a>Runtime 源码</h4><p>在 runtime 中，ivar_t 结构存储 ivar 相关信息，其中 offset 是一个指向全局变量的指针，这个全局变量中存储着 ivar 的偏移量。</p><p>class_ro_t 结构存储类的各种信息，其中 instanceStart 记录 ivar 开始的偏移量，instanceSize 记录类的大小，ivars 是 ivar_t 数组，记录所有的 ivar 信息。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ivar_t &#123;</span><br><span class="line"><span class="meta">#if __x86_64__</span></span><br><span class="line">    <span class="comment">// *offset was originally 64-bit on some x86_64 platforms.</span></span><br><span class="line">    <span class="comment">// We read and write only 32 bits of it.</span></span><br><span class="line">    <span class="comment">// Some metadata provides all 64 bits. This is harmless for unsigned </span></span><br><span class="line">    <span class="comment">// little-endian values.</span></span><br><span class="line">    <span class="comment">// Some code uses all 64 bits. class_addIvar() over-allocates the </span></span><br><span class="line">    <span class="comment">// offset for their benefit.</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    int32_t *offset;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;</span><br><span class="line">    <span class="comment">// alignment is sometimes -1; use alignment() instead</span></span><br><span class="line">    uint32_t alignment_raw;</span><br><span class="line">    uint32_t size;</span><br><span class="line"></span><br><span class="line">    uint32_t alignment() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (alignment_raw == ~(uint32_t)<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>U &lt;&lt; WORD_SHIFT;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; alignment_raw;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> class_ro_t &#123;</span><br><span class="line">    uint32_t flags;</span><br><span class="line">    uint32_t instanceStart;</span><br><span class="line">    uint32_t instanceSize;</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">    uint32_t reserved;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * ivarLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;</span><br><span class="line">    method_list_t * baseMethodList;</span><br><span class="line">    protocol_list_t * baseProtocols;</span><br><span class="line">    <span class="keyword">const</span> ivar_list_t * ivars;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> uint8_t * weakIvarLayout;</span><br><span class="line">    property_list_t *baseProperties;</span><br><span class="line"></span><br><span class="line">    method_list_t *baseMethods() <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 App 启动时会加载所有的类，每个类都会调用到 moveIvars 方法。在 moveIvars 方法中，遍历 class_ro_t.ivars 中的所有 ivar_t，更新 offset。最后，更新 class_ro_t.instanceStart 和 class_ro_t.instanceSize。之后创建实例时，根据 instanceSize 来申请内存空间。</p><p>对 moveIvars 的具体实现感兴趣的朋友，可以自己下载 runtime 源码来阅读。<br><a href="https://github.com/opensource-apple/objc4" target="_blank" rel="noopener">GitHub - opensource-apple/objc4</a></p><p>至此，动态申请内存空间和动态更新 offset 的目标都达到了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下 OC 是如何实现 Non-fragile ivar 特性的：</p><ol><li>每个成员变量都有一个与之对应的全局变量，用于记录成员变量的偏移量。</li><li>类信息保存在 class_ro_t 结构体中，其中 ivars 保存所有成员变量的偏移量等信息，同时用 instanceSize 记录类的大小。</li><li>App 启动时，调用 moveIvars 方法更新 ivar-&gt;offset 和 instanceSize，创建实例时根据 instanceSize 来申请所需内存。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://www.sealiesoftware.com/blog/archive/2009/01/27/objc_explain_Non-fragile_ivars.html" target="_blank" rel="noopener">Hamster Emporium: objc explain: Non-fragile ivars</a></li><li><a href="http://www.cocoawithlove.com/2010/03/dynamic-ivars-solving-fragile-base.html" target="_blank" rel="noopener">Dynamic ivars: solving a fragile base class problem</a></li><li><a href="https://www.jianshu.com/p/c105a65da934" target="_blank" rel="noopener">Mach-O文件介绍之ASLR(进程地址空间布局随机化) - 简书</a></li><li><a href="https://winddoing.github.io/post/7190.html" target="_blank" rel="noopener">ARMv8-aarch64寄存器和指令集 | Winddoing’s Blog</a></li><li><a href="https://blog.cnbluebox.com/blog/2017/07/24/arm64-start/" target="_blank" rel="noopener">iOS开发同学的arm64汇编入门 - 刘坤的技术博客</a></li><li><a href="http://abcdxyzk.github.io/blog/2012/11/23/assembly-args/" target="_blank" rel="noopener">64位汇编参数传递 - kk Blog —— 通用基础</a></li></ul><blockquote><p>汇编函数调用参数传递：</p><ol><li>在真机 ARM64 架构中，x0 ~ x7 用于传递参数</li><li>在64位模拟器中，rdi, rsi, rdx, rcx, r8, r9 用于传递参数</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Objective-C 是一门动态语言。所谓动态，在于消息发送和转发，在于 Method Swizzling，同时也在于 Non-fragile ivar。之前有一篇文章简单介绍过消息发送和转发（&lt;a href=&quot;/2016/01/24/programing/iOS/tutorial/02MethodResolve/&quot;&gt;iOS教程（二）消息发送&lt;/a&gt;），这一篇主要介绍下 Non-fragile ivar 特性及其实现方式。&lt;/p&gt;
&lt;h2 id=&quot;什么是-ivar-？&quot;&gt;&lt;a href=&quot;#什么是-ivar-？&quot; class=&quot;headerlink&quot; title=&quot;什么是 ivar ？&quot;&gt;&lt;/a&gt;什么是 ivar ？&lt;/h2&gt;&lt;p&gt;ivar（instance variable）就是类成员变量。一般情况下，property 都会自动生成一个成员变量。&lt;/p&gt;
&lt;p&gt;假设有一个 MyObject 类，有 array 和 color 两个成员变量， MyObject 实例的内存结构如下：&lt;br&gt;&lt;img src=&quot;/images/ivar-layout.jpeg&quot; alt=&quot;ivar-layout&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果要获取 color 的值，self 指针加上偏移量，再解引用就可以了，这也是 runtime 获取成员变量的方式。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;UIColor&lt;/span&gt; *color = *(&lt;span class=&quot;built_in&quot;&gt;UIColor&lt;/span&gt; *)((&lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; *)&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; + &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;当然，runtime 的逻辑比这复杂，例如 atomic 加锁等。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Non-fragile-ivar-？&quot;&gt;&lt;a href=&quot;#什么是-Non-fragile-ivar-？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Non-fragile ivar ？&quot;&gt;&lt;/a&gt;什么是 Non-fragile ivar ？&lt;/h2&gt;&lt;p&gt;fragile 的含义是脆弱的，Non-fragile ivar 解决的是 fragile ivar 的问题。&lt;/p&gt;
&lt;h4 id=&quot;fragile-ivar-问题&quot;&gt;&lt;a href=&quot;#fragile-ivar-问题&quot; class=&quot;headerlink&quot; title=&quot;fragile ivar 问题&quot;&gt;&lt;/a&gt;fragile ivar 问题&lt;/h4&gt;&lt;p&gt;在 32 位的 Mac 上，假定有一个 NSCustomView 继承自 NSView，NSCustomView 有两个成员变量。（至于为什么是 32 位的 Mac，接下来会介绍。）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="http://jefferyfan.com/categories/Programing/"/>
    
      <category term="iOS" scheme="http://jefferyfan.com/categories/Programing/iOS/"/>
    
    
      <category term="iOS" scheme="http://jefferyfan.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://jefferyfan.com/tags/Objective-C/"/>
    
      <category term="ivar" scheme="http://jefferyfan.com/tags/ivar/"/>
    
  </entry>
  
  <entry>
    <title>iOS weak 的底层实现原理</title>
    <link href="http://jefferyfan.com/2019/11/15/programing/iOS/weak//"/>
    <id>http://jefferyfan.com/2019/11/15/programing/iOS/weak//</id>
    <published>2019-11-15T12:47:26.000Z</published>
    <updated>2019-11-21T14:39:51.981Z</updated>
    
    <content type="html"><![CDATA[<p>在 iOS 开发中，weak property 或者是  <code>__weak</code> 修饰的变量，在对象释放后，变量会自动置为 nil。delegate 模式、block 中 weak strong dance 都会用到。</p><p>比如，声明一个 weak 的 delegate。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> delegate;</span><br></pre></td></tr></table></figure><p>weak 用的好可以避免内存泄漏和野指针崩溃。weak 有这么大的作用，底层具体是咋实现的呢？本文探讨下 weak 的底层实现原理。</p><h3 id="初探-weak-实现"><a href="#初探-weak-实现" class="headerlink" title="初探 weak 实现"></a>初探 weak 实现</h3><p>首先通过汇编来看下，底层怎么实现的。先写几行代码。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> referent = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> weakObj = referent;</span><br><span class="line">    <span class="built_in">NSLog</span>(@“%@“, weakObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Xcode 中勾选 Debug -&gt; Debug Workflow -&gt; Always Show Disassembly，然后在 NSLog 行加个断点，运行之后可以看到这样一段汇编代码：</p><p><img src="/images/weak-disassembly.png" alt="disassembly code"></p><a id="more"></a><p>这里可以看到 3 个 weak 相关的函数，很容易对应到刚刚的三行代码中。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> referent = [<span class="built_in">NSObject</span> new];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// __weak id weakObj = referent;</span></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> weakObj;</span><br><span class="line">    objc_initWeak(&amp;weakObj, referent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NSLog(@"%@", weakObj);</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, objc_loadWeak(&amp;weakObj));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// weakObj 离开作用域，销毁</span></span><br><span class="line">    objc_destroyWeak(&amp;weakObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道这三个函数那就好说了，从 github 上可以下载到 runtime 的源码来研究。<a href="https://github.com/opensource-apple/objc4" target="_blank" rel="noopener">GitHub - opensource-apple/objc4</a></p><h3 id="底层存储结构"><a href="#底层存储结构" class="headerlink" title="底层存储结构"></a>底层存储结构</h3><p>这里不过多的粘贴源码，简单介绍下 weak 底层的存储结构。</p><p><img src="/images/weak-struct.png" alt="weak 底层存储结构"></p><p>先解释两个单词，referent 是指 weak 变量指向的对象，referrer 是指 weak 变量。</p><p>最外层是一个 <code>StripedMap</code>，以 referent 实例地址作为 key，通过哈希，平均映射到 64 个 <code>SideTable</code> 中。<br><code>SideTable</code> 中最关键的一个成员是 <code>weak_table</code>，<code>weak_table</code> 的成员 <code>weak_entries</code> 是一个 <code>weak_entry_t</code> 结构体数组，每一个 <code>weak_entry_t</code> 结构体都保存着 referent 地址和指向这个 referent 的所有 weak 变量地址，也就是 referrers 数组。</p><h3 id="runtime-源码解释"><a href="#runtime-源码解释" class="headerlink" title="runtime 源码解释"></a>runtime 源码解释</h3><p>了解了结构，再来单独聊聊刚刚在汇编中看到的几个函数。</p><ul><li><p><code>objc_initWeak</code><br>通过 referent 去找 SideTable，再遍历  <code>weak_entries</code>  找到对应的 weak entry（ <code>weak_entry_t</code> 结构体），将 weak 变量地址添加到对应的 referrers 数组中。当然，如果没有找到 weak entry，会创建一个。</p></li><li><p><code>objc_loadWeak</code><br>本身 weak 变量已经指向了 referent。<code>objc_loadWeak</code> 内部检查是否是 tag pointer、是否允许 weak reference 等等条件。并查找是否有对应的 weak entry，如果能找到且各种条件满足，则返回 referent 地址，否则返回 nil。</p></li></ul><p>⚠️ 这里返回的 referent 地址，在 runtime 层已经 retain &amp; autorelease。</p><ul><li><code>objc_destroyWeak</code><br>这个函数就是 <code>objc_initWeak</code> 的反向操作，把 weak 变量指针从 referrers 数组中移出。如果 referrers 数组为空，那么也顺带会移除 weak entry。</li></ul><p>讲了这么多，那这些 weak 指针置为 nil 的逻辑在哪里呢？<br>从 NSObject 的 dealloc 源码入手，可以看到最后调用到了  <code>weak_clear_no_lock</code>  方法。</p><ul><li><code>weak_clear_no_lock</code><br>这个函数主要逻辑是找到对应的 weak entry，遍历 referrers 数组，将所有的 weak 变量都置为 nil，再将 weak entry 移除掉。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 iOS 开发中，weak property 或者是  &lt;code&gt;__weak&lt;/code&gt; 修饰的变量，在对象释放后，变量会自动置为 nil。delegate 模式、block 中 weak strong dance 都会用到。&lt;/p&gt;
&lt;p&gt;比如，声明一个 weak 的 delegate。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@property&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;nonatomic&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; delegate;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;weak 用的好可以避免内存泄漏和野指针崩溃。weak 有这么大的作用，底层具体是咋实现的呢？本文探讨下 weak 的底层实现原理。&lt;/p&gt;
&lt;h3 id=&quot;初探-weak-实现&quot;&gt;&lt;a href=&quot;#初探-weak-实现&quot; class=&quot;headerlink&quot; title=&quot;初探 weak 实现&quot;&gt;&lt;/a&gt;初探 weak 实现&lt;/h3&gt;&lt;p&gt;首先通过汇编来看下，底层怎么实现的。先写几行代码。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; referent = [&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; new];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __&lt;span class=&quot;keyword&quot;&gt;weak&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt; weakObj = referent;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(@“%@“, weakObj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在 Xcode 中勾选 Debug -&amp;gt; Debug Workflow -&amp;gt; Always Show Disassembly，然后在 NSLog 行加个断点，运行之后可以看到这样一段汇编代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/weak-disassembly.png&quot; alt=&quot;disassembly code&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="http://jefferyfan.com/categories/Programing/"/>
    
      <category term="iOS" scheme="http://jefferyfan.com/categories/Programing/iOS/"/>
    
    
      <category term="iOS" scheme="http://jefferyfan.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://jefferyfan.com/tags/Objective-C/"/>
    
      <category term="weak" scheme="http://jefferyfan.com/tags/weak/"/>
    
      <category term="内存管理" scheme="http://jefferyfan.com/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS 教程（三）事件响应链</title>
    <link href="http://jefferyfan.com/2019/11/06/programing/iOS/tutorial/03responder//"/>
    <id>http://jefferyfan.com/2019/11/06/programing/iOS/tutorial/03responder//</id>
    <published>2019-11-06T14:44:19.000Z</published>
    <updated>2019-11-21T14:31:13.134Z</updated>
    
    <content type="html"><![CDATA[<p>在我们点击屏幕的时候，系统捕获到触摸事件，系统把包含这些触摸事件的信息包装成 UITouch 和 UIEvent 实例，然后找到当前运行的应用，逐级寻找能够响应这个事件的对象，直到没有响应者响应。这一系列响应者组成了响应链。</p><p>首先，系统捕获到点击行为后，将点击事件封装成 UIEvent 对象。接下来，就需要确定具体触摸到哪个 view，也即是找到手指触摸到的处于屏幕最前端的 view，这一步叫 hit-testing。</p><h3 id="hit-testing"><a href="#hit-testing" class="headerlink" title="hit-testing"></a>hit-testing</h3><p>UIView 中有两个方法，hitTest 和 pointInside：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="keyword">nullable</span> <span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="keyword">nullable</span> <span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure><p>pointInside 方法是判断 point 是否在当前 view 内。<br>hitTest 方法是调用 pointInside 函数判断触点是否在当前 view 内，以及递归调用子 view 的 hitTest 方法，找到实际触摸的 view。</p><a id="more"></a><p>把这两个函数自己实现了一遍，如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)pointInside:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CGRectContainsPoint</span>(<span class="keyword">self</span>.bounds, point);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.userInteractionEnabled ||</span><br><span class="line">        <span class="keyword">self</span>.alpha &lt;= <span class="number">0.01</span> ||</span><br><span class="line">        <span class="keyword">self</span>.hidden) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> pointInside:point withEvent:event]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIView</span> *hitView = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSInteger</span> subViewCount = [<span class="keyword">self</span>.subviews count];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = subViewCount - <span class="number">1</span>; index &gt;= <span class="number">0</span>; --index) &#123;</span><br><span class="line">        <span class="built_in">UIView</span> *subView = <span class="keyword">self</span>.subviews[index];</span><br><span class="line">        <span class="keyword">if</span> (subView.userInteractionEnabled &amp;&amp; subView.alpha &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">CGPoint</span> pointInSub = [subView convertPoint:point fromView:<span class="keyword">self</span>];</span><br><span class="line">            hitView = [subView hitTest:pointInSub withEvent:event];</span><br><span class="line">            <span class="keyword">if</span> (hitView) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (hitView == <span class="literal">nil</span>) &#123;</span><br><span class="line">        hitView = <span class="keyword">self</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> hitView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意，hitTest 方法中的 point 是已经转化到当前 view 的坐标系的，也即是当前 view 的左上角为 (0, 0)。所以当递归调用子 view 的 hitTest 方法时，也要注意转化到子 view 的坐标系。</p><p>系统也正是从 UIWindow 开始，层层递归调用 hitTest 方法，直到找到实际触摸到处于屏幕最前端的 view，姑且称之为 target-view 吧。</p><p>⚠️ 注意，UIEvent 会和 target-view 绑定，target-view 一旦确定，整个触摸过程中 target-view 都不会再改变，即使手指滑动离开了 target-view 的范围。</p><blockquote><p>那么问题来了，如果 view.clipToBounds = NO，而且 subview 有超出 view 的部分。那么点击 subview 超过 view 的部分，view 的 hitTest 会返回什么呢？</p><p>答案是返回 nil 哦。</p></blockquote><p>理解了 hitTest 和 pointInside 的逻辑之后，重写 hitTest 和 pointInside 可以只有圆形区域响应事件的效果，这里就不再细讲了。</p><h3 id="响应链"><a href="#响应链" class="headerlink" title="响应链"></a>响应链</h3><p>所有需要响应触摸事件的类，都继承自 UIResponder，UIResponder 的子类有：UIView、UIApplication、UIViewController。响应链中的每个元素都是 UIResponder 的子类实例。</p><p>UIResponder 中有 4 个触摸事件处理方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="keyword">nullable</span> <span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="keyword">nullable</span> <span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="keyword">nullable</span> <span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="keyword">nullable</span> <span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure><p>同时，UIResponser 中有一个 nextResponder 的属性，nextResponder 就是下一个响应者。</p><p>我们写一个 demo 来看下 nextResponder 都返回什么值。新建一个 ViewController 类，其中部分代码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.title = @“ResponderChainDemo”;</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> navBarBottom = <span class="built_in">CGRectGetMaxY</span>(<span class="keyword">self</span>.navigationController.navigationBar.frame) + <span class="keyword">self</span>.navigationController.view.window.windowScene.statusBarManager.statusBarFrame.size.height;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGFloat</span> side = <span class="number">200</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> redViewX = (<span class="keyword">self</span>.view.bounds.size.width - side) / <span class="number">2.0</span>f;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// UINamedView 继承自 UIView，并有一个 name 属性</span></span><br><span class="line">    <span class="keyword">self</span>.redView = [[[<span class="built_in">UINamedView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(redViewX, navBarBottom + <span class="number">10</span>, side, side)] autorelease];</span><br><span class="line">    <span class="keyword">self</span>.redView.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    <span class="keyword">self</span>.redView.name = <span class="string">@"RedView"</span>;</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.redView];</span><br><span class="line">    </span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">0.1</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> printResponder];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)printResponder &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"printResponder with nextResponder"</span>);</span><br><span class="line">    <span class="built_in">UIResponder</span> *responder = <span class="keyword">self</span>.redView;</span><br><span class="line">    <span class="keyword">while</span> (responder) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([responder isKindOfClass:[<span class="built_in">UINamedView</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@ (%@)"</span>, [responder <span class="keyword">class</span>], [(<span class="built_in">UINamedView</span> *)responder name]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [responder <span class="keyword">class</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        responder = [responder nextResponder];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行之后的 Log 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">UINamedView (RedView)</span><br><span class="line">UIView</span><br><span class="line">ViewController</span><br><span class="line">UIViewControllerWrapperView</span><br><span class="line">UINavigationTransitionView</span><br><span class="line">UILayoutContainerView</span><br><span class="line">UINavigationController</span><br><span class="line">UIDropShadowView</span><br><span class="line">UITransitionView</span><br><span class="line">UIWindow</span><br><span class="line">UIWindowScene</span><br><span class="line">UIApplication</span><br><span class="line">AppDelegate</span><br></pre></td></tr></table></figure><p>我们可以看到，响应链通过 nextResponder 属性将 UIResponder 都连接起来了。</p><p>响应链的结构大致是：view -&gt; superview -&gt; ViewController -&gt; UIWindow -&gt; UIWindowScene -&gt; UIApplication -&gt; AppDelegate，ViewController、UIApplication、AppDelegate 都在响应链中。</p><p>如果存在子 controller，响应链的结构大致是：view -&gt; ChildViewController -&gt; ViewController.view -&gt; ViewController -&gt; …</p><p>借用苹果官方文档的图来说明下，更直观。<br><img src="/images/iOS_and_OSX_responder_chain_2x.png" alt="iOS_and_OSX_responder_chain_2x"></p><p>系统会调用 UIApplication 的 sendEvent: 方法，继而调用 UIWindow 的 sendEvent: 方法。在 UIWindow 的 sendEvent: 方法中会调用 target-view 的触摸事件处理方法，事件也就开始在响应链中传递。如果 target-view 不处理这些事件，则通过 nextResponder 传递给下一个 responder 处理，这也是默认逻辑。如果 target-view 已经处理了这些事件了，则不需要往 nextResponder 传递，比如 UIButton。</p><p>⚠️ 在重写子类的事件处理方法时，不要手动传递事件给 nextResponder。应该通过调用 super 的事件处理方法，来把事件传递给 nextResponder。</p><h3 id="手势-UIGestureRecognizer"><a href="#手势-UIGestureRecognizer" class="headerlink" title="手势 UIGestureRecognizer"></a>手势 UIGestureRecognizer</h3><p>给 view 添加手势后，touchesBegan 和 touchesMoved 仍旧会被调用，与没有添加手势时的逻辑一致。<br>如果 gesture 识别成功，则 touchesCancelled 被调用，否则 touchesEnded 被调用。</p><h3 id="正确构造响应链"><a href="#正确构造响应链" class="headerlink" title="正确构造响应链"></a>正确构造响应链</h3><p>大部分的情况下，系统都会自动正确的构造响应链。例如，通过 addSubview 添加子 view 时，子 view 的 nextResponder 会自动的指向 superview，不需要写额外的逻辑。</p><p>但是，需要特别注意 UIViewController。有好些朋友创建子 controller 只是单纯的 addSubview，例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)displayContentController: (<span class="built_in">UIViewController</span>*) content &#123;</span><br><span class="line">   content.view.frame = [<span class="keyword">self</span> frameForContentController];</span><br><span class="line">   [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.currentClientView];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样会导致子 controller 没有在响应链中，子 controller 的 viewDidAppear 等回调缺失。<br>正确的写法应该是：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) displayContentController: (<span class="built_in">UIViewController</span>*) content &#123;</span><br><span class="line">   [<span class="keyword">self</span> addChildViewController:content];</span><br><span class="line">   content.view.frame = [<span class="keyword">self</span> frameForContentController];</span><br><span class="line">   [<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.currentClientView];</span><br><span class="line">   [content didMoveToParentViewController:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，移除 ViewController 也不仅仅是 removeFromSuperview 方法调用。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) hideContentController: (<span class="built_in">UIViewController</span>*) content &#123;</span><br><span class="line">   [content willMoveToParentViewController:<span class="literal">nil</span>];</span><br><span class="line">   [content.view removeFromSuperview];</span><br><span class="line">   [content removeFromParentViewController];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="firstResponder"><a href="#firstResponder" class="headerlink" title="firstResponder"></a>firstResponder</h3><p>firstResponder 听起来像是通过 hit-testing 找到的 target-view。实际上，优先接收某些事件（例如键盘 KeyEvent、MotionEvent等）的响应者，称之为 firstResponder。而触摸事件中的 target-view，可能是 firstResponder，也可能不是。</p><p>最简单的例子就是，调用 UITextField 的 becomeFirstResponder 方法，可以激活键盘并输入文字。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://www.cocoachina.com/articles/14896" target="_blank" rel="noopener">iOS开发 - 事件传递响应链 - CocoaChina_一站式开发者成长社区</a><br><a href="https://developer.apple.com/documentation/uikit/touches_presses_and_gestures/using_responders_and_the_responder_chain_to_handle_events?language=objc" target="_blank" rel="noopener">Using Responders and the Responder Chain to Handle Events | Apple Developer Documentation</a><br><a href="https://stackoverflow.com/questions/30438847/difference-between-addchildviewcontroller-and-addsubview" target="_blank" rel="noopener">iOS - Difference between addChildViewController and addSubview? - Stack Overflow</a><br><a href="https://developer.apple.com/library/archive/featuredarticles/ViewControllerPGforiPhoneOS/ImplementingaContainerViewController.html" target="_blank" rel="noopener">View Controller Programming Guide for iOS: Implementing a Container View Controller</a><br><a href="http://zhoon.github.io/ios/2015/04/12/ios-event.html" target="_blank" rel="noopener">深入浅出iOS事件机制</a><br><a href="http://smnh.me/hit-testing-in-ios/" target="_blank" rel="noopener">Hit-Testing in iOS</a><br><a href="http://southpeak.github.io/2015/03/07/cocoa-uikit-uiresponder/" target="_blank" rel="noopener">UIKit: UIResponder | 南峰子的技术博客</a><br><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/Devpedia-CocoaApp/Responder.html" target="_blank" rel="noopener">Responder object</a></p><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p><a href="/2016/01/24/programing/iOS/tutorial/02MethodResolve/">iOS教程（二）消息发送</a><br><a href="/2015/04/12/programing/iOS/tutorial/01MemoryManage/">iOS教程（一）iOS内存管理</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在我们点击屏幕的时候，系统捕获到触摸事件，系统把包含这些触摸事件的信息包装成 UITouch 和 UIEvent 实例，然后找到当前运行的应用，逐级寻找能够响应这个事件的对象，直到没有响应者响应。这一系列响应者组成了响应链。&lt;/p&gt;
&lt;p&gt;首先，系统捕获到点击行为后，将点击事件封装成 UIEvent 对象。接下来，就需要确定具体触摸到哪个 view，也即是找到手指触摸到的处于屏幕最前端的 view，这一步叫 hit-testing。&lt;/p&gt;
&lt;h3 id=&quot;hit-testing&quot;&gt;&lt;a href=&quot;#hit-testing&quot; class=&quot;headerlink&quot; title=&quot;hit-testing&quot;&gt;&lt;/a&gt;hit-testing&lt;/h3&gt;&lt;p&gt;UIView 中有两个方法，hitTest 和 pointInside：&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;UIView&lt;/span&gt; *)hitTest:(&lt;span class=&quot;built_in&quot;&gt;CGPoint&lt;/span&gt;)point withEvent:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;UIEvent&lt;/span&gt; *)event;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;built_in&quot;&gt;BOOL&lt;/span&gt;)pointInside:(&lt;span class=&quot;built_in&quot;&gt;CGPoint&lt;/span&gt;)point withEvent:(&lt;span class=&quot;keyword&quot;&gt;nullable&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;UIEvent&lt;/span&gt; *)event;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;pointInside 方法是判断 point 是否在当前 view 内。&lt;br&gt;hitTest 方法是调用 pointInside 函数判断触点是否在当前 view 内，以及递归调用子 view 的 hitTest 方法，找到实际触摸的 view。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="http://jefferyfan.com/categories/Programing/"/>
    
      <category term="iOS" scheme="http://jefferyfan.com/categories/Programing/iOS/"/>
    
    
      <category term="iOS" scheme="http://jefferyfan.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://jefferyfan.com/tags/Objective-C/"/>
    
      <category term="UIKit" scheme="http://jefferyfan.com/tags/UIKit/"/>
    
      <category term="Responder" scheme="http://jefferyfan.com/tags/Responder/"/>
    
  </entry>
  
  <entry>
    <title>如何屏蔽 Universal Link 调端？</title>
    <link href="http://jefferyfan.com/2018/03/17/programing/iOS/block-universal-link//"/>
    <id>http://jefferyfan.com/2018/03/17/programing/iOS/block-universal-link//</id>
    <published>2018-03-17T07:56:20.000Z</published>
    <updated>2019-11-21T14:31:21.678Z</updated>
    
    <content type="html"><![CDATA[<p>苹果在 iOS 9 开始提供 Universal Link 唤起 App 的能力。Universal Link 时机上是一个 https 链接，在用户点击网页中的 https 链接时，先尝试唤起 App，唤起失败则加载对应的网页。</p><p>相比于使用 <code>scheme://</code> 这种 scheme 的方式唤起 App，Universal Link 唤起的优点在于苹果并未提供接口进行拦截，一般 App 不会进行拦截。并且在唤起失败时，能自动加载对应的页面。</p><p>因此，业内使用 Universal Link 唤起 App的逐渐增多。用户被恶意导流至其他 App 的问题日益严重。本文研究 iOS Universal Link 唤起 App 的逻辑，找到拦截 Universal Link 的方案。</p><a id="more"></a><h2 id="LSAppLink"><a href="#LSAppLink" class="headerlink" title="LSAppLink"></a>LSAppLink</h2><p>查过一番资料后，得知唤起 App 会调用 <code>+[LSAppLink openWithURL:completionHandler:]</code> 方法。<br>经过测试，不同固件，不同调端方法和类型的表现也有一些差别，如下：</p><table><thead><tr><th>固件</th><th>方法</th><th>测试结果</th></tr></thead><tbody><tr><td>iOS 9.2</td><td><code>-[UIApplication openURL:]</code></td><td>调用了 <code>+[LSAppLink openWithURL:completionHandler:]</code></td></tr><tr><td>iOS 9.2</td><td>点击页面a链接(UIWebView)</td><td>调用了 <code>+[LSAppLink openWithURL:completionHandler:]</code></td></tr><tr><td>iOS 10.3.3</td><td><code>-[UIApplication openURL:]</code></td><td>不调用 <code>LSAppLink</code></td></tr><tr><td>iOS 10.3.3</td><td><code>-[UIApplication openURL:options:completionHandler:]</code> &amp;&amp; options = @{}</td><td>不调用 <code>LSAppLink</code></td></tr><tr><td>iOS 10.3.3</td><td><code>-[UIApplication openURL:options:completionHandler:]</code> &amp;&amp; options = @{UIApplicationOpenURLOptionUniversalLinksOnly : @(YES)}</td><td>调用了 <code>+[LSAppLink openWithURL:completionHandler:]</code></td></tr><tr><td>iOS 10.3.3</td><td>点击页面a链接(UIWebView)</td><td>调用了 <code>+[LSAppLink openWithURL:completionHandler:]</code></td></tr></tbody></table><br/>从这测试结果，我们可以总结出以下结论：<ol><li>由<code>UIWebView</code>发起的 App 唤起，都会调用到 <code>+[LSAppLink openWithURL:completionHandler:]</code></li><li><code>openURL</code>的方式唤起 App，也有可能会经过 <code>+[LSAppLink openWithURL:completionHandler:]</code>，因此最后拦截 UL 唤起的时候需要排除调来自 <code>openURL</code> 的，避免主动唤起时仍旧被拦截。</li></ol><h2 id="LSAppLink-内部实现"><a href="#LSAppLink-内部实现" class="headerlink" title="LSAppLink 内部实现"></a>LSAppLink 内部实现</h2><p>既然知道 UL 唤起一定会调用<code>+[LSAppLink openWithURL:completionHandler:]</code>，那么就看下这个方法是如何实现的，以决定是否可以通过hook这个方法来拦截 UL 唤起。</p><h3 id="hook-LSAppLink"><a href="#hook-LSAppLink" class="headerlink" title="hook LSAppLink"></a>hook LSAppLink</h3><p>通过 OC Runtime，hook <code>+[LSAppLink openWithURL:completionHandler:]</code> 方法，可以发现，第一个参数为<code>NSURL *</code>类型，第二个参数为<code>block</code>，<code>block</code>接收两个参数，<code>BOOL</code> 和 <code>NSError *</code>。<br>因此，完整的声明为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (void)openWithURL:(NSURL *)url completionHandler:(void(^)(BOOL, NSError *))handler;</span><br></pre></td></tr></table></figure><p>从这方法声明上可以大概看出，尝试 UL 唤起后，唤起结果通过 handler 回调，如果唤起失败，UIWebView 再加载对应的网页。</p><p>hook 方法后，不进行任何操作，只回调 handler，网页也是可以正常加载。这也验证了刚刚的猜想。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (void)myopenWithURL:(id)url completionHandler:(id)handler</span><br><span class="line">&#123;</span><br><span class="line">    NSError *tmpErr = [NSError errorWithDomain:@&quot;NSOSStatusErrorDomain&quot; code:-5500 userInfo:@&#123;&#125;];</span><br><span class="line">    ((void (^)(BOOL, id))(handler))(NO, tmpErr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反编译系统lib"><a href="#反编译系统lib" class="headerlink" title="反编译系统lib"></a>反编译系统lib</h3><p>LSAppLink 类在 MobileCoreService.framework 中。</p><p>通过 ssh 连接到越狱的测试手机，执行<code>find / | grep MobileCoreService</code>定位到<code>/System/Library/Frameworks/</code>路径下有一堆 framework。通过 scp 将 Frameworks 全部拷贝到 mac 上，然而发现这些 framework 中都只包含一些 strings，并没有 lib！</p><p>参考 <a href="https://stackoverflow.com/questions/10830488/where-are-the-ios-frameworks-binaries-located-in-the-filesystem" target="_blank" rel="noopener">Where are the iOS frameworks binaries located in the filesystem?</a></p><blockquote><p>The binaries no longer exist on-device (and have not since iOS 3.1): Apple has merged them all into one large mmap()’ed cache file, to make app launch a bit more efficient. As the pages usually never change, the kernel can effectively share them between every running image. You can still use dlopen() on files held within the cache, as dyld short-circuits file lookup when the given library exists in the cache.  </p></blockquote><blockquote><p>The cache file is in /System/Library/Caches/com.apple.dyld, and is named after the architecture (armv6 or armv7). The libraries within can be extracted using dsc_extractor or KennyTM’s dyld_decache, available in this repository, but once extracted they can’t actually be loaded into memory properly (as they all effectively get their symbol tables merged in the cache.)  </p></blockquote><p>系统做过优化，所有的 framework 合并成一个文件了。在<code>/System/Library/Caches/com.apple.dyld/</code>目录下，找到了 dyld，通过 scp 拷贝到 mac 上。</p><p>通过 Hopper 反编译 dyld，需要配置 <a href="https://github.com/0xc010d/DYLDSharedCache.hopperLoader" target="_blank" rel="noopener">DYLDSharedCache.hopperLoader</a> 才能正常反编译，否则会有大量的<code>&lt;redacted&gt;</code>。</p><p><code>+[LSAppLink openWithURL:completionHandler:]</code>反编译后的伪代码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">int +[LSAppLink openWithURL:completionHandler:](int arg0, int arg1, int arg2, int arg3) &#123;</span><br><span class="line">    *(r31 + 0xffffffffffffffc0) = r24;</span><br><span class="line">    *(r31 + 0xffffffffffffffc8) = r23;</span><br><span class="line">    *(r31 + 0xffffffffffffffd0) = r22;</span><br><span class="line">    *(r31 + 0xffffffffffffffd8) = r21;</span><br><span class="line">    *(r31 + 0xffffffffffffffe0) = r20;</span><br><span class="line">    *(r31 + 0xffffffffffffffe8) = r19;</span><br><span class="line">    *(r31 + 0xfffffffffffffff0) = r29;</span><br><span class="line">    *(r31 + 0xfffffffffffffff8) = r30;</span><br><span class="line">    r29 = r31 + 0xfffffffffffffff0;</span><br><span class="line">    r31 = r31 + 0xffffffffffffffc0 - 0x50;</span><br><span class="line">    r19 = arg3;</span><br><span class="line">    r21 = arg2;</span><br><span class="line">    r22 = arg1;</span><br><span class="line">    r20 = arg0;</span><br><span class="line">    if (__LSIsServer() != 0x0) &#123;</span><br><span class="line">            if (loc_1800b9bc0(*(@selector(startOpenOperation:connection:) + 0x8e0), *0x19d2848b8, &quot;/BuildRoot/Library/Caches/com.apple.xbs/Sources/CoreServices/CoreServices-727.6.2/LaunchServices.subprj/Source/LaunchServices/Workspace/LSAppLink.mm&quot;) != 0x0) &#123;</span><br><span class="line">                    asm&#123; csel       x23, x0, x8 &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            r0 = *(@selector(startOpenOperation:connection:) + 0x958);</span><br><span class="line">            loc_1800b9bc0(r0, *0x19d2848c0);</span><br><span class="line">            *(r31 + 0x18) = r31;</span><br><span class="line">            *(r31 + 0x20) = r31;</span><br><span class="line">            *(r31 + 0x8) = r31;</span><br><span class="line">            *(r31 + 0x10) = r31;</span><br><span class="line">            r31 = r31;</span><br><span class="line">            loc_1800b9bc0();</span><br><span class="line">    &#125;</span><br><span class="line">    r0 = *(@selector(startOpenOperation:connection:) + 0xa30);</span><br><span class="line">    loc_1800b9bc0(r0, *0x19d2841a0);</span><br><span class="line">    loc_1800b9bc0();</span><br><span class="line">    r22 = loc_1800b9bc0();</span><br><span class="line">    loc_1800b9bc0();</span><br><span class="line">    r21 = loc_1800b9bc0(r22, *(@selector(startOpenOperation:connection:) + 0x198));</span><br><span class="line">    r0 = loc_1800b9bc0(r20, *(@selector(startOpenOperation:connection:) + 0x158));</span><br><span class="line">    *(r31 + 0x28) = *___destroy_helper_block_160;</span><br><span class="line">    *(r31 + 0x30) = zero_extend_64(0xc200);</span><br><span class="line">    *(r31 + 0x38) = r31;</span><br><span class="line">    *(r31 + 0x38) = 0x181ee8da4;</span><br><span class="line">    *(r31 + 0x40) = 0x199b20ec0;</span><br><span class="line">    *(r31 + 0x48) = r19;</span><br><span class="line">    r0 = __LSOpenAppLink(r21, r0, r31 + 0x28);</span><br><span class="line">    r31 = r29 - 0x30;</span><br><span class="line">    return r0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>+[LSAppLink openWithURL:completionHandler:]</code>最后调用了<code>__LSOpenAppLink</code>方法来唤起。</p><p>依据<code>__LSOpenAppLink</code>的汇编和Hopper提供的伪代码，整理出一份比较直观的伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">void _LSOpenAppLink(NSData* data, OS_dispatch_queue *queue, (void (^)(BOOL, NSError *)) handler)</span><br><span class="line">&#123;</span><br><span class="line">    if (data &amp;&amp; queue &amp;&amp; handler)</span><br><span class="line">    &#123;</span><br><span class="line">        OS_xpc_dictionary *xpcInfo = xpc_dictionary_create(0, 0, 0);    // 0x000000013ce69b50</span><br><span class="line">        if (xpcInfo)</span><br><span class="line">        &#123;</span><br><span class="line">            xpc_dictionary_set_int64(xpcInfo, &quot;LSXPCMessage&quot;, 0x25);</span><br><span class="line">            _LSXPCDictionarySetCFObject(xpcInfo, &quot;LSData&quot;, );</span><br><span class="line">            xpc_dictionary_set_mach_recv(xpcInfo, &quot;LSXPCKey4&quot;, SBSCreateClientEntitlementEnforcementPort());</span><br><span class="line">            /*</span><br><span class="line">            此时，xpcInfo的内容为：</span><br><span class="line">            &lt;OS_xpc_dictionary: dictionary[0x13ce69b50]: &#123; refcnt = 1, xrefcnt = 1, count = 3, dest port = 0x0 &#125; &lt;dictionary: 0x13ce69b50&gt; &#123; count = 3, contents =</span><br><span class="line">                &quot;LSXPCMessage&quot; =&gt; &lt;int64: 0x13cd85350&gt;: 37</span><br><span class="line">                &quot;LSData&quot; =&gt; &lt;data: 0x13ce40450&gt;: &#123; length = 1379 bytes, contents = 0x7b2255524c223a2268747470733a5c2f5c2f626f7865722e... &#125;</span><br><span class="line">                &quot;LSXPCKey4&quot; =&gt; &lt;mach receive right: 0x13ce47fe0&gt; &#123; name = 0xae3f, right = receive &#125;</span><br><span class="line">            &#125;&gt;</span><br><span class="line">            */</span><br><span class="line"> </span><br><span class="line">            OS_xpc_connection *connection = _LSCopyServerConnection(xpcInfo);</span><br><span class="line">            xpc_connection_send_message_with_reply(connection, xpcInfo, queue, handler);</span><br><span class="line">             </span><br><span class="line">            xpc_release(connection);</span><br><span class="line">            xpc_release(xpcInfo);</span><br><span class="line">            // go to 0x182e23430</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            // go to 0x182e23430</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        // go to 0x182e23408</span><br><span class="line">        if (handler)</span><br><span class="line">        &#123;</span><br><span class="line">            // invoke handler</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            // go to 0x182e23430</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>_LSOpenAppLink</code>函数的主要逻辑为：</p><ol><li>创建 xpc 调用需要的字典，填充相关字段</li><li>创建 xpc connection</li><li>发送 xpc 消息</li></ol><p>在<code>+[LSAppLink openWithURL:completionHandler:]</code>的 comletionHandler 中加断点，可以看到xpc回调结束后的栈为：</p><p><img src="/images/fa9139d4b5cdadff4398b0fbf1771ea5.png" alt="fa9139d4b5cdadff4398b0fbf1771ea5"></p><p>分析到这里，可以得出初步结论：</p><ol><li>系统在 xpc 调用前也无法确定 URL 是否能 UL 唤起 App。</li><li>在<code>LSAppLink</code>之前是 WebKit 调用，在<code>+[LSAppLink openWithURL:completionHandler:]</code>之后是 C 方法 xpc 调用，因此 hook <code>+[LSAppLink openWithURL:completionHandler:]</code>进行拦截 UL 是最合适的方法。</li></ol><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>综合以上的分析，最后确定拦截方案为：</p><ol><li>在 UIWebView 中的 shouldStartLoad 中判断 UL 唤起的前置条件判断，例如 https 链接、naviationType判断。如果满足前置条件，hook <code>LSAppLink</code>方法。</li><li>在hook的<code>LSAppLink</code>方法中，通过下发名单判断是否允许 UL 唤起，如果不允许则直接回调completionHandler。</li><li>为尽量减少审核风险，拦截完后将hook恢复。</li></ol><p>⚠️ <strong>此方案hook了系统私有API，有比较大的审核风险，须配合其他加密手段来实现。</strong></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li><p>Universal Link 需要在服务器根目录放一个配置文件：apple-app-site-association，其中 appID 字段的格式为<code>teamID.bundle</code>，例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"applinks"</span>: &#123;</span><br><span class="line">        <span class="attr">"apps"</span>: [],</span><br><span class="line">        <span class="attr">"details"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"appID"</span>: <span class="string">"teamID.com.yyy.iphone"</span>,</span><br><span class="line">                <span class="attr">"paths"</span>: [ <span class="string">"/path/*"</span> ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>排查 UL 调起问题时，请注意是否有 https 抓包，如果抓取 https UL 链接，会导致UL无法调端</p></li><li><p>WKWebView 和 UIWebView 行为存在差异。WKWebView 支持点击后中间页通过<code>window.location.replace</code>方式 UL 调端，而 UIWebView 不支持此种方式。</p></li></ol><h2 id="参考-amp-amp-资料"><a href="#参考-amp-amp-资料" class="headerlink" title="参考 &amp;&amp; 资料"></a>参考 &amp;&amp; 资料</h2><ol><li><a href="https://github.com/nst/iOS-Runtime-Headers" target="_blank" rel="noopener">iOS-Runtime-Headers</a></li><li><a href="https://github.com/nst/RuntimeBrowser" target="_blank" rel="noopener">RuntimeBrowser</a></li><li><a href="https://github.com/0xc010d/DYLDSharedCache.hopperLoader" target="_blank" rel="noopener">DYLDSharedCache.hopperLoader</a></li><li><a href="https://github.com/deepinstinct/dsc_fix" target="_blank" rel="noopener">fix IDA dyld loader</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;苹果在 iOS 9 开始提供 Universal Link 唤起 App 的能力。Universal Link 时机上是一个 https 链接，在用户点击网页中的 https 链接时，先尝试唤起 App，唤起失败则加载对应的网页。&lt;/p&gt;
&lt;p&gt;相比于使用 &lt;code&gt;scheme://&lt;/code&gt; 这种 scheme 的方式唤起 App，Universal Link 唤起的优点在于苹果并未提供接口进行拦截，一般 App 不会进行拦截。并且在唤起失败时，能自动加载对应的页面。&lt;/p&gt;
&lt;p&gt;因此，业内使用 Universal Link 唤起 App的逐渐增多。用户被恶意导流至其他 App 的问题日益严重。本文研究 iOS Universal Link 唤起 App 的逻辑，找到拦截 Universal Link 的方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="http://jefferyfan.com/categories/Programing/"/>
    
      <category term="iOS" scheme="http://jefferyfan.com/categories/Programing/iOS/"/>
    
    
      <category term="iOS" scheme="http://jefferyfan.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://jefferyfan.com/tags/Objective-C/"/>
    
      <category term="Universal Link" scheme="http://jefferyfan.com/tags/Universal-Link/"/>
    
      <category term="调端" scheme="http://jefferyfan.com/tags/%E8%B0%83%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>装饰者模式（Decorator）</title>
    <link href="http://jefferyfan.com/2017/05/07/programing/design-pattern/decorator//"/>
    <id>http://jefferyfan.com/2017/05/07/programing/design-pattern/decorator//</id>
    <published>2017-05-07T04:49:01.000Z</published>
    <updated>2019-11-21T14:34:10.664Z</updated>
    
    <content type="html"><![CDATA[<p>这是设计模式系列第三篇博文，装饰者模式，也是《Head First 设计模式》的学习笔记。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong>装饰者模式</strong> 动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p></blockquote><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>老套路，为了后面讨论的需要，先简单的复述下《Head First 设计模式》中的例子（简化版）。</p><ol><li>星巴克中有一系列的咖啡（Coffee），其中一种为 DarkRoast。</li><li>咖啡可以配上不同的调料，假设有两种调料 Mocha 和 Whip。</li><li>顾客点咖啡之后，可以自主选择调料。</li></ol><p>在这三个条件之下，要怎么来设计星巴克的点单系统，以计算出最后的价格？</p><p>可以把咖啡和调料都抽象成顾客需要消费的产品（Beverage），咖啡对象和调料对象都实现 Beverage 协议。</p><a id="more"></a><p><img src="/images/Decorator.png" alt="Decorato"></p><p>每个 Beverage 对象的<code>cost</code>方法把自己的价格加上<code>beverage</code>成员的价格再返回即可。例如：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">double</span>)cost</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.1</span>f + [<span class="keyword">self</span>.beverage cost];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当用户点单 DarkRoast 并添加 Mocha 和 Whip 调料时，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id&lt;Beverage&gt; beverage = [DarkRoast new];</span><br><span class="line">beverage = [[Mocha alloc] initWithBeverage:beverage];</span><br><span class="line">beverage = [[Whip alloc] initWithBeverage:beverage];</span><br></pre></td></tr></table></figure><p>最后在订单中保存<code>beverage</code>对象即可。</p><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>其实这种咖啡加调料的案例也可以用<a href="/2017/04/16/programing/design-pattern/strategy/">策略模式（Strategy Pattern）</a>来做。</p><p>定义一个协议<code>Condiment</code>来表示调料，<code>Coffee</code>类表示咖啡。<br><code>Coffee</code>中提供一个<code>addCondiment</code>的方法添加调料，提供<code>cost</code>方法返回价格。</p><p>用策略模式也可以实现这个需求，但是两者哪种更好或者说更优雅呢？<br>首先，两种方式都可以达到目的，那就主要比较下两者的扩展性。<br>假设后续需要增加一种包装，普通外带包装，干冰外带包装。那按照策略模式，其实还得再修改<code>Coffee</code>类，增加一个方法<code>addPackage</code>方法来解决这个场景。而按照装饰者模式，则只需要增加包装的装饰类即可。</p><p>策略模式和装饰者模式对比：</p><ol><li>策略模式有明显的从属关系，例如<a href="/2017/04/16/programing/design-pattern/strategy/">策略模式（Strategy Pattern）</a>中提到的<code>Duck</code>，<code>FlyBehavior</code>从属于<code>Duck</code>，不可能存在<code>Duck</code>从属于<code>FlyBehavior</code>。而在装饰者模式者，每个装饰者都是平等的，A 可以装饰 B，B 也可以装饰 A。</li><li>策略模式中，主体和行为本质不是同一类别（<code>Duck</code>和<code>Behavior</code>不同类别）。而装饰者模式模式中，每个装饰者都是同一类别，都有共同的属性或者行为（咖啡，调料，包装都属于顾客购买的产品）。</li></ol><p>想明白这两个区别之后，再来决定是策略模式还是装饰者模式的时候就更清晰明了了。</p><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><blockquote><p> 类应该对扩展开放，对修改关闭。</p></blockquote><h3 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h3><p><a href="/2017/04/16/programing/design-pattern/strategy/">策略模式（Strategy Pattern）</a><br><a href="/2017/04/20/programing/design-pattern/observer/">观察者模式（Observer Pattern）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是设计模式系列第三篇博文，装饰者模式，也是《Head First 设计模式》的学习笔记。&lt;/p&gt;
&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;装饰者模式&lt;/strong&gt; 动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;老套路，为了后面讨论的需要，先简单的复述下《Head First 设计模式》中的例子（简化版）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;星巴克中有一系列的咖啡（Coffee），其中一种为 DarkRoast。&lt;/li&gt;
&lt;li&gt;咖啡可以配上不同的调料，假设有两种调料 Mocha 和 Whip。&lt;/li&gt;
&lt;li&gt;顾客点咖啡之后，可以自主选择调料。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这三个条件之下，要怎么来设计星巴克的点单系统，以计算出最后的价格？&lt;/p&gt;
&lt;p&gt;可以把咖啡和调料都抽象成顾客需要消费的产品（Beverage），咖啡对象和调料对象都实现 Beverage 协议。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="http://jefferyfan.com/categories/Programing/"/>
    
      <category term="Design Pattern" scheme="http://jefferyfan.com/categories/Programing/Design-Pattern/"/>
    
    
      <category term="Design Pattern" scheme="http://jefferyfan.com/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Python 学习笔记</title>
    <link href="http://jefferyfan.com/2017/05/03/programing/python/python//"/>
    <id>http://jefferyfan.com/2017/05/03/programing/python/python//</id>
    <published>2017-05-03T14:41:08.000Z</published>
    <updated>2019-11-21T14:32:07.100Z</updated>
    
    <content type="html"><![CDATA[<p>也不是经常使用 Python，每次用时都忘的差不多，又需要重新查资料。所以，开篇博客记录下这些琐碎的知识点。<br>都是入门基础级别的知识点，大神请出门左拐👋👋。</p><h4 id="获取日期"><a href="#获取日期" class="headerlink" title="获取日期"></a>获取日期</h4><p><a href="https://docs.python.org/2/library/datetime.html" target="_blank" rel="noopener">Python lib doc: datetime</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按格式打印当前时间</span></span><br><span class="line"><span class="keyword">print</span> datetime.datetime.now().strftime(<span class="string">'%m-%d'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按格式打印昨天时间</span></span><br><span class="line">delta = datetime.timedelta(<span class="number">1</span>)</span><br><span class="line">yestoday = datetime.datetime.now() - delta</span><br><span class="line"><span class="keyword">print</span> yestoday.strftime(<span class="string">'%m-%d'</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="列表（list）"><a href="#列表（list）" class="headerlink" title="列表（list）"></a>列表（list）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array = [<span class="string">'a'</span>, <span class="string">'abc'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选</span></span><br><span class="line">array = [item <span class="keyword">for</span> item <span class="keyword">in</span> array <span class="keyword">if</span> item.startswith(<span class="string">'a'</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并list</span></span><br><span class="line">array.extend([<span class="string">'e'</span>, <span class="string">'f'</span>])</span><br></pre></td></tr></table></figure><h4 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h4><ul><li>文件夹操作 Sample</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, shutil</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建文件夹</span></span><br><span class="line">os.mkdir(<span class="string">'folder'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件夹</span></span><br><span class="line">os.rmdir(<span class="string">'empty_folder'</span>)  <span class="comment"># 只能删除空文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.path.exists(<span class="string">'folder'</span>):</span><br><span class="line">    shutil.rmtree(<span class="string">'folder'</span>)     <span class="comment"># 删除不存在的文件夹时，会抛异常</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动</span></span><br><span class="line">os.rename(<span class="string">"path/to/current/file.foo"</span>, <span class="string">"path/to/new/destination/for/file.foo"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历文件夹</span></span><br><span class="line"><span class="keyword">for</span> curdir, dirnames, filenames <span class="keyword">in</span> os.walk(<span class="string">'folder'</span>):</span><br><span class="line">    <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">        path = os.path.join(curdir, filename)</span><br><span class="line">        <span class="keyword">print</span> path</span><br></pre></td></tr></table></figure><ul><li>JSON存取 Sample</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json, codecs</span><br><span class="line"></span><br><span class="line"><span class="comment"># JSON存盘</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'result.json'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    json.dump(data, file, ensure_ascii=<span class="literal">False</span>, indent = <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 ensure_ascii=False 和文件编码为utf-8，解决json中包含中文无法写入的问题</span></span><br><span class="line"><span class="keyword">with</span> codecs.open(<span class="string">'result.json'</span>, <span class="string">'w'</span>, <span class="string">'utf-8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    json.dump(data, file, ensure_ascii=<span class="literal">False</span>, indent = <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># JSON读取</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'gz020.json'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    data = json.load(file)</span><br></pre></td></tr></table></figure><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找</span></span><br><span class="line">re.findall(<span class="string">r'ing'</span>, <span class="string">'string_input'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多行匹配</span></span><br><span class="line"><span class="comment"># 1. 必须使用非贪婪模式</span></span><br><span class="line"><span class="comment"># 2. flags需要带上 re.DOTALL 和 re.MULTILINE</span></span><br><span class="line">re.findall(<span class="string">r'&lt;table class="olt"&gt;.*?&lt;/table&gt;'</span>, string, flags=re.DOTALL+re.MULTILINE)</span><br></pre></td></tr></table></figure><h4 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'Accept'</span> : <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span> : <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendReq</span><span class="params">(url, body, headers)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        req = urllib2.Request(url, body, headers)</span><br><span class="line">        <span class="keyword">return</span> urllib2.urlopen(req).read()</span><br><span class="line">    <span class="keyword">except</span> Exception, e:</span><br><span class="line">        <span class="keyword">print</span> e</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">response = sendReq(<span class="string">'https://m.baidu.com/'</span>, <span class="string">''</span>, headers)</span><br><span class="line"><span class="keyword">print</span> response</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;也不是经常使用 Python，每次用时都忘的差不多，又需要重新查资料。所以，开篇博客记录下这些琐碎的知识点。&lt;br&gt;都是入门基础级别的知识点，大神请出门左拐👋👋。&lt;/p&gt;
&lt;h4 id=&quot;获取日期&quot;&gt;&lt;a href=&quot;#获取日期&quot; class=&quot;headerlink&quot; title=&quot;获取日期&quot;&gt;&lt;/a&gt;获取日期&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://docs.python.org/2/library/datetime.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Python lib doc: datetime&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; datetime&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 按格式打印当前时间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; datetime.datetime.now().strftime(&lt;span class=&quot;string&quot;&gt;&#39;%m-%d&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 按格式打印昨天时间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;delta = datetime.timedelta(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yestoday = datetime.datetime.now() - delta&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; yestoday.strftime(&lt;span class=&quot;string&quot;&gt;&#39;%m-%d&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="http://jefferyfan.com/categories/Programing/"/>
    
      <category term="Python" scheme="http://jefferyfan.com/categories/Programing/Python/"/>
    
    
      <category term="Python" scheme="http://jefferyfan.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式（Observer Pattern）</title>
    <link href="http://jefferyfan.com/2017/04/20/programing/design-pattern/observer//"/>
    <id>http://jefferyfan.com/2017/04/20/programing/design-pattern/observer//</id>
    <published>2017-04-20T15:33:07.000Z</published>
    <updated>2019-11-21T14:33:44.689Z</updated>
    
    <content type="html"><![CDATA[<p>这是设计模式系列第二篇博文，观察者模式，也是《Head First 设计模式》的学习笔记。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>主题（Subject）：主题对象管理某些数据。<br>观察者（Observer）：监听主题的数据变化，执行响应的操作。</p></blockquote><blockquote><p><strong>观察者模式</strong> 定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p></blockquote><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h3><p>在日常开发中，经常用到观察者模式，相信大家都已经对观察者模式烂熟于心。但是是不是真的用的好呢？我提几个问题，看看大家是否有思考过，也欢迎留言讨论。</p><h4 id="通知数据更新，是选择以推的方式来实现还是以拉的方式来实现？各有哪些优缺点？"><a href="#通知数据更新，是选择以推的方式来实现还是以拉的方式来实现？各有哪些优缺点？" class="headerlink" title="通知数据更新，是选择以推的方式来实现还是以拉的方式来实现？各有哪些优缺点？"></a>通知数据更新，是选择以推的方式来实现还是以拉的方式来实现？各有哪些优缺点？</h4><p>我们先定义下推和拉。<br><strong>推的方式</strong>：通知 Observer 数据有更新时，通知把更新后的数据通过参数一起传递过去；<br><strong>拉的方式</strong>：数据更新时，只通知 Observer 数据有更新，具体需要哪些数据由 Observer 主动调 Subject 的接口查询。</p><p>拉的方式，Observer 并不知道具体更新的数据是哪些。收到数据更新时，只能一股脑的把自己需要的数据都重新查询一遍，有时候是很低效的。其次，有时候 Observer 需要知道更新前的数据以及更新后的数据，使用拉的方式也无法解决这种场景。</p><p>如果选择推的方式，以上两个缺点都可以解决。但是同时也带来了一个新的问题。在推的方式中，更新的数据是以参数来传递的。当需要新增参数时，就需要修改所有 Observer 的方法，略蛋疼。</p><p>但其实也不是没有解决方法，可以使用一个 model 来传递。当通知更新的参数大于三个时，建议以传递 model 的方式来通知更新。</p><a id="more"></a><h4 id="Subject-是否需要支持线程安全？"><a href="#Subject-是否需要支持线程安全？" class="headerlink" title="Subject 是否需要支持线程安全？"></a>Subject 是否需要支持线程安全？</h4><p>这个主要还是看使用场景。<br>往往 Observer 观察到数据变化时，简单计算后刷新 UI。在 iOS 上，必须在主线程中刷新 UI 界面。博主以为，为了保证效率，这种情况可以是线程不安全的，但建议在代码中增加<code>assert</code>，在开发阶段发现和解决多线程使用的问题。</p><h4 id="在通知-Observer-过程中，是否允许调用addObserver或者removeObserver来添加或者移除观察者？"><a href="#在通知-Observer-过程中，是否允许调用addObserver或者removeObserver来添加或者移除观察者？" class="headerlink" title="在通知 Observer 过程中，是否允许调用addObserver或者removeObserver来添加或者移除观察者？"></a>在通知 Observer 过程中，是否允许调用<code>addObserver</code>或者<code>removeObserver</code>来添加或者移除观察者？</h4><p>Subject 中一般用数组或者集合来保存所有 Observer。在iOS中，在遍历数组的过程中修改数组，会抛异常。<br>博主建议，<code>addObserver</code>或者<code>removeObserver</code>时，如果发现正在遍历 Observer 通知数据更新，则将 Observer 数组拷贝一份，操作这份拷贝。在通知 Observer 完毕时，再替换为拷贝后的数组。</p><p>一般情况下，Subject 的 Observer 不会太多，拷贝 Observer 数组并不会有太大的性能消耗。</p><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><blockquote><p>为了交互对象之间的松耦合设计而努力。</p></blockquote><h3 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h3><p><a href="/2017/04/16/programing/design-pattern/strategy/">策略模式（Strategy Pattern）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是设计模式系列第二篇博文，观察者模式，也是《Head First 设计模式》的学习笔记。&lt;/p&gt;
&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;主题（Subject）：主题对象管理某些数据。&lt;br&gt;观察者（Observer）：监听主题的数据变化，执行响应的操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;观察者模式&lt;/strong&gt; 定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;讨论&quot;&gt;&lt;a href=&quot;#讨论&quot; class=&quot;headerlink&quot; title=&quot;讨论&quot;&gt;&lt;/a&gt;讨论&lt;/h3&gt;&lt;p&gt;在日常开发中，经常用到观察者模式，相信大家都已经对观察者模式烂熟于心。但是是不是真的用的好呢？我提几个问题，看看大家是否有思考过，也欢迎留言讨论。&lt;/p&gt;
&lt;h4 id=&quot;通知数据更新，是选择以推的方式来实现还是以拉的方式来实现？各有哪些优缺点？&quot;&gt;&lt;a href=&quot;#通知数据更新，是选择以推的方式来实现还是以拉的方式来实现？各有哪些优缺点？&quot; class=&quot;headerlink&quot; title=&quot;通知数据更新，是选择以推的方式来实现还是以拉的方式来实现？各有哪些优缺点？&quot;&gt;&lt;/a&gt;通知数据更新，是选择以推的方式来实现还是以拉的方式来实现？各有哪些优缺点？&lt;/h4&gt;&lt;p&gt;我们先定义下推和拉。&lt;br&gt;&lt;strong&gt;推的方式&lt;/strong&gt;：通知 Observer 数据有更新时，通知把更新后的数据通过参数一起传递过去；&lt;br&gt;&lt;strong&gt;拉的方式&lt;/strong&gt;：数据更新时，只通知 Observer 数据有更新，具体需要哪些数据由 Observer 主动调 Subject 的接口查询。&lt;/p&gt;
&lt;p&gt;拉的方式，Observer 并不知道具体更新的数据是哪些。收到数据更新时，只能一股脑的把自己需要的数据都重新查询一遍，有时候是很低效的。其次，有时候 Observer 需要知道更新前的数据以及更新后的数据，使用拉的方式也无法解决这种场景。&lt;/p&gt;
&lt;p&gt;如果选择推的方式，以上两个缺点都可以解决。但是同时也带来了一个新的问题。在推的方式中，更新的数据是以参数来传递的。当需要新增参数时，就需要修改所有 Observer 的方法，略蛋疼。&lt;/p&gt;
&lt;p&gt;但其实也不是没有解决方法，可以使用一个 model 来传递。当通知更新的参数大于三个时，建议以传递 model 的方式来通知更新。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="http://jefferyfan.com/categories/Programing/"/>
    
      <category term="Design Pattern" scheme="http://jefferyfan.com/categories/Programing/Design-Pattern/"/>
    
    
      <category term="Design Pattern" scheme="http://jefferyfan.com/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 自定义域名（托管在 Github）</title>
    <link href="http://jefferyfan.com/2017/04/18/guide/hexo-github-custom-host//"/>
    <id>http://jefferyfan.com/2017/04/18/guide/hexo-github-custom-host//</id>
    <published>2017-04-18T14:40:24.000Z</published>
    <updated>2019-11-21T14:30:18.127Z</updated>
    
    <content type="html"><![CDATA[<p>最近 Vultr 的 VPS 越来越不给力，挂在 Vultr VPS 上的博客加载速度越来越慢。遂决定将博客迁回 github pages。</p><p>其实很简单，两步搞定：</p><ul><li>首先，在 github 博客仓库根目录下新建一个文件，文件名<code>CNAME</code>，文件内容为自定义的域名，例如：blog.duxevr.com</li><li>在 DNS 服务商那增加一个<code>CNAME</code>记录，指向 github 博客的地址。<br>github 博客的 url 为 YOUR-GITHUB-NAME.github.io，例如我的 github 博客url为：jefferyfan.github.io。</li></ul><p>Hexo 配置相关文章：</p><ul><li><a href="/2016/07/24/guide/hexo-custom-host-vps/">Hexo博客自定义域名和部署到VPS</a></li><li><a href="/2015/07/22/guide/hexo-guide/">Hexo博客使用教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近 Vultr 的 VPS 越来越不给力，挂在 Vultr VPS 上的博客加载速度越来越慢。遂决定将博客迁回 github pages。&lt;/p&gt;
&lt;p&gt;其实很简单，两步搞定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，在 github 博客仓库根目录下新建一个文件，文件名&lt;cod
      
    
    </summary>
    
    
      <category term="Guide" scheme="http://jefferyfan.com/categories/Guide/"/>
    
      <category term="Hexo" scheme="http://jefferyfan.com/categories/Guide/Hexo/"/>
    
    
      <category term="Guide" scheme="http://jefferyfan.com/tags/Guide/"/>
    
      <category term="Hexo" scheme="http://jefferyfan.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>策略模式（Strategy Pattern）</title>
    <link href="http://jefferyfan.com/2017/04/16/programing/design-pattern/strategy//"/>
    <id>http://jefferyfan.com/2017/04/16/programing/design-pattern/strategy//</id>
    <published>2017-04-16T11:17:32.000Z</published>
    <updated>2019-11-21T14:33:36.491Z</updated>
    
    <content type="html"><![CDATA[<p>在大学的时候，看过一本设计模式的书。那时是上网找的pdf，书名不记得了。但是印象最深刻的是，那本书特别晦涩难懂，翻译的特别拗口。虽然硬着头皮看完了，但是记住的没有多少。</p><p>如今，买了一本《Head First 设计模式》，开始重新学习设计模式。边学边记录，算是学习笔记吧。这篇是《Head First 设计模式》学习笔记第一篇：策略模式。<br>（好吧，我又开了一个坑，能不能坚持写完还另说。）</p><h3 id="从问题入手"><a href="#从问题入手" class="headerlink" title="从问题入手"></a>从问题入手</h3><p>《Head First 设计模式》书中提到的<code>Duck</code>的例子非常的形象，我用自己的画重新表述一遍，跟书中略有区别。</p><ol><li>需要实现一个鸭子<code>Duck</code>类，鸭子有一种行为：飞行</li><li>正常的鸭子会飞，但是玩具鸭不会飞。</li></ol><p>我们很自然的想到，实现基类<code>Duck</code>类，提供一个默认的<code>fly</code>方法，玩具鸭重写<code>fly</code>方法，提供一个空实现。</p><p>或者是基类不提供<code>fly</code>方法实现，实现两个子类<code>FlyableDuck</code>和<code>ToyDuck</code>，其中<code>FlyableDuck</code>表示会飞的鸭子，实现<code>fly</code>方法；<code>ToyDuck</code>表示玩具鸭，提供空的<code>fly</code>方法。</p><p>就我列出的两点的要求来说，两个方法都可以实现。但有以下缺点：</p><ul><li>方法一：如果后续新增加一种不会飞的鸭子时，需要关心父类已经实现了对应的<code>fly</code>方法，需要主动覆盖<code>fly</code>方法</li><li>方法二：如果后续新增一种叫的行为，分为吱吱叫、呱呱叫，飞行行为也分为蜻蜓点水飞行、低空飞行两种，那是不是就得实现四个类表示行为两两组合的鸭子呢？</li></ul><a id="more"></a><p>那么接下来，再提几个要求：</p><ol><li>鸭子分为普通鸭，池塘鸭，旱鸭，玩具鸭</li><li>普通鸭会低空飞行，吱吱叫，池塘鸭会蜻蜓点水飞行，呱呱叫；旱鸭会低空飞行，呱呱叫；玩具鸭不会飞，会吱吱叫。</li></ol><p>那这又该如何实现呢？</p><p>这个时候，再通过继承来实现不不太现实了。需要把飞行和叫这两种行为抽象出来，作为单独的行为类去实现，再给不同的鸭子分配不同的行为。</p><p><img src="/images/Duck.png" alt="Duck"></p><p>这就是<strong>策略模式</strong>。说白了，就是组合。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p><strong>策略模式</strong> 定义算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p></blockquote><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><p>《Head First 设计模式》中提到几个设计原则：</p><blockquote><ol><li>找出引用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li><li>针对接口编程，而不是针对实现编程。</li><li><strong>多用组合，少用继承。</strong></li></ol></blockquote><p>在面向对象的思想中，继承用的非常多，导致很多人习惯性的使用继承来解决问题，忽略了组合。<br>下次如果在使用继承解决类似问题时，<strong>请停下来思考思考，使用策略模式（组合）来解决是否更适合？</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在大学的时候，看过一本设计模式的书。那时是上网找的pdf，书名不记得了。但是印象最深刻的是，那本书特别晦涩难懂，翻译的特别拗口。虽然硬着头皮看完了，但是记住的没有多少。&lt;/p&gt;
&lt;p&gt;如今，买了一本《Head First 设计模式》，开始重新学习设计模式。边学边记录，算是学习笔记吧。这篇是《Head First 设计模式》学习笔记第一篇：策略模式。&lt;br&gt;（好吧，我又开了一个坑，能不能坚持写完还另说。）&lt;/p&gt;
&lt;h3 id=&quot;从问题入手&quot;&gt;&lt;a href=&quot;#从问题入手&quot; class=&quot;headerlink&quot; title=&quot;从问题入手&quot;&gt;&lt;/a&gt;从问题入手&lt;/h3&gt;&lt;p&gt;《Head First 设计模式》书中提到的&lt;code&gt;Duck&lt;/code&gt;的例子非常的形象，我用自己的画重新表述一遍，跟书中略有区别。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要实现一个鸭子&lt;code&gt;Duck&lt;/code&gt;类，鸭子有一种行为：飞行&lt;/li&gt;
&lt;li&gt;正常的鸭子会飞，但是玩具鸭不会飞。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们很自然的想到，实现基类&lt;code&gt;Duck&lt;/code&gt;类，提供一个默认的&lt;code&gt;fly&lt;/code&gt;方法，玩具鸭重写&lt;code&gt;fly&lt;/code&gt;方法，提供一个空实现。&lt;/p&gt;
&lt;p&gt;或者是基类不提供&lt;code&gt;fly&lt;/code&gt;方法实现，实现两个子类&lt;code&gt;FlyableDuck&lt;/code&gt;和&lt;code&gt;ToyDuck&lt;/code&gt;，其中&lt;code&gt;FlyableDuck&lt;/code&gt;表示会飞的鸭子，实现&lt;code&gt;fly&lt;/code&gt;方法；&lt;code&gt;ToyDuck&lt;/code&gt;表示玩具鸭，提供空的&lt;code&gt;fly&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;就我列出的两点的要求来说，两个方法都可以实现。但有以下缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法一：如果后续新增加一种不会飞的鸭子时，需要关心父类已经实现了对应的&lt;code&gt;fly&lt;/code&gt;方法，需要主动覆盖&lt;code&gt;fly&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;方法二：如果后续新增一种叫的行为，分为吱吱叫、呱呱叫，飞行行为也分为蜻蜓点水飞行、低空飞行两种，那是不是就得实现四个类表示行为两两组合的鸭子呢？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="http://jefferyfan.com/categories/Programing/"/>
    
      <category term="Design Pattern" scheme="http://jefferyfan.com/categories/Programing/Design-Pattern/"/>
    
    
      <category term="Design Pattern" scheme="http://jefferyfan.com/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>使用WKWebView打开itunes链接无法跳转至AppStore</title>
    <link href="http://jefferyfan.com/2017/04/10/programing/iOS/wkwebview-itunes//"/>
    <id>http://jefferyfan.com/2017/04/10/programing/iOS/wkwebview-itunes//</id>
    <published>2017-04-09T17:35:18.000Z</published>
    <updated>2019-11-21T14:32:29.099Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>UIWebView</code>上，不需要特殊处理直接加载 itunes 链接是可以直接跳转至AppStore的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://itunes.apple.com/cn/app/id1013277346?mt=8"</span>];</span><br><span class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</span><br><span class="line">    </span><br><span class="line"><span class="keyword">self</span>.webView = [<span class="built_in">UIWebView</span> new];</span><br><span class="line"><span class="keyword">self</span>.webView.delegate = <span class="keyword">self</span>;</span><br><span class="line">[<span class="keyword">self</span>.webView loadRequest:request];</span><br></pre></td></tr></table></figure><p>但是，在WKWebView上则不行，需要在<code>navigationDelegate</code>中拦截，手动<code>openURL</code>才能跳转至AppStore。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)loadWithWKWebView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"https://itunes.apple.com/cn/app/id1013277346?mt=8"</span>];</span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.wkWebView = [<span class="built_in">WKWebView</span> new];</span><br><span class="line">    <span class="keyword">self</span>.wkWebView.navigationDelegate = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span>.wkWebView loadRequest:request];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class="built_in">WKNavigationAction</span> *)navigationAction decisionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">WKNavigationActionPolicy</span>))decisionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">WKNavigationActionPolicy</span> policy = <span class="built_in">WKNavigationActionPolicyAllow</span>;</span><br><span class="line">    <span class="comment">/* 简单判断host，真实App代码中，需要更精确判断itunes链接 */</span></span><br><span class="line">    <span class="keyword">if</span> ([[navigationAction.request.URL host] isEqualToString:<span class="string">@"itunes.apple.com"</span>] &amp;&amp;</span><br><span class="line">        [[<span class="built_in">UIApplication</span> sharedApplication] openURL:navigationAction.request.URL])</span><br><span class="line">    &#123;</span><br><span class="line">        policy = <span class="built_in">WKNavigationActionPolicyCancel</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    decisionHandler(policy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>难以理解为啥WKWebView上不支持跳转至AppStore。<br>如果不处理，普通网页上链接至itunes的，点击后都无法跳转了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;code&gt;UIWebView&lt;/code&gt;上，不需要特殊处理直接加载 itunes 链接是可以直接跳转至AppStore的。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="Programing" scheme="http://jefferyfan.com/categories/Programing/"/>
    
      <category term="iOS" scheme="http://jefferyfan.com/categories/Programing/iOS/"/>
    
    
      <category term="iOS" scheme="http://jefferyfan.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://jefferyfan.com/tags/Objective-C/"/>
    
      <category term="WKWebView" scheme="http://jefferyfan.com/tags/WKWebView/"/>
    
  </entry>
  
  <entry>
    <title>CATransaction 踩坑：completion block 没有立即调用</title>
    <link href="http://jefferyfan.com/2016/11/13/programing/iOS/CATransaction-trap//"/>
    <id>http://jefferyfan.com/2016/11/13/programing/iOS/CATransaction-trap//</id>
    <published>2016-11-13T10:53:21.000Z</published>
    <updated>2019-11-21T14:33:15.563Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过一篇博客，介绍CATransaction的使用：<a href="/2016/06/27/programing/iOS/CATransaction/">理解CATransaction</a>。文中提到，当需要监听动画结束时，可以利用<code>-[CATransaction setCompletionBlock:]</code>方法监听动画的结束，而不用修改接口参数。然而，利用这个方法监听动画结束，有一定的风险会导致 completionBlock 不被调用。</p><p>简单例子如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">CATransaction</span> begin];</span><br><span class="line">[<span class="built_in">CATransaction</span> setCompletionBlock:^&#123;</span><br><span class="line">    <span class="comment">//complete block</span></span><br><span class="line">&#125;];</span><br><span class="line">[<span class="keyword">self</span> doAnimation]</span><br><span class="line">[<span class="built_in">CATransaction</span> commit];</span><br></pre></td></tr></table></figure><p>一般情况下 completionBlock都会被调用。</p><p><strong>但是当<code>[self doAnimation]</code>中做了一个<code>repeatCount=HUGE_VALF</code>的动画时，动画永远不会结束，因此， completionBlock 就永远不会被调用。</strong></p><p>在同一个类中利用<code>CATransaction</code>来监听动画结束问题不大，但是做动画的代码中还会调用外面的类的话，就需要小心了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前写过一篇博客，介绍CATransaction的使用：&lt;a href=&quot;/2016/06/27/programing/iOS/CATransaction/&quot;&gt;理解CATransaction&lt;/a&gt;。文中提到，当需要监听动画结束时，可以利用&lt;code&gt;-[CATransac
      
    
    </summary>
    
    
      <category term="Programing" scheme="http://jefferyfan.com/categories/Programing/"/>
    
      <category term="iOS" scheme="http://jefferyfan.com/categories/Programing/iOS/"/>
    
    
      <category term="iOS" scheme="http://jefferyfan.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://jefferyfan.com/tags/Objective-C/"/>
    
      <category term="CATransaction" scheme="http://jefferyfan.com/tags/CATransaction/"/>
    
  </entry>
  
  <entry>
    <title>大端规则和小端规则</title>
    <link href="http://jefferyfan.com/2016/08/07/programing/base/big-little-endian//"/>
    <id>http://jefferyfan.com/2016/08/07/programing/base/big-little-endian//</id>
    <published>2016-08-07T11:24:03.000Z</published>
    <updated>2019-11-21T14:31:56.202Z</updated>
    
    <content type="html"><![CDATA[<p>一个int型整数，一般情况下占4个字节。那么这4个字节在内存中是怎么排列的呢？低内存地址存放的是低位字节还是高位子节呢？这就涉及到大端规则和小端规则。</p><p>这是一个特别小特别基础的知识点，在大部分的日常开发中，我们并不需要理会大小端规则。但是当涉及到跨平台网络数据传输的时候，就需要考虑大小端规则了。</p><h3 id="大端规则（Big－Endian）"><a href="#大端规则（Big－Endian）" class="headerlink" title="大端规则（Big－Endian）"></a>大端规则（Big－Endian）</h3><p>将高位字节存储在低位地址，低位字节存储在高位地址，这种存储方式成为大端规则，也称为大端序。</p><p>以<code>0xA1A2A3A4</code>为例，使用大端规则，内存排列如下：</p><table><thead><tr><th align="center">低地址&emsp;——&gt;</th><th align="center">——&gt;</th><th align="center">——&gt;</th><th align="center">——&gt;&emsp;高低地址</th></tr></thead><tbody><tr><td align="center">0xA1</td><td align="center">0xA2</td><td align="center">0xA3</td><td align="center">0xA4</td></tr></tbody></table><a id="more"></a><h3 id="小端规则（Little-Endian）"><a href="#小端规则（Little-Endian）" class="headerlink" title="小端规则（Little-Endian）"></a>小端规则（Little-Endian）</h3><p>将低位字节存储在低位地址，高位字节存储在高位地址，这种存储方式成为小端规则，也称为小端序。</p><p>以<code>0xA1A2A3A4</code>为例，使用小端规则，内存排列如下：</p><table><thead><tr><th align="center">低地址&emsp;——&gt;</th><th align="center">——&gt;</th><th align="center">——&gt;</th><th align="center">——&gt;&emsp;高低地址</th></tr></thead><tbody><tr><td align="center">0xA4</td><td align="center">0xA3</td><td align="center">0xA2</td><td align="center">0xA1</td></tr></tbody></table><h3 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h3><p>不同平台使用不同的字节序。为了保证网络传输的数据能够被所有平台正确读取，TCP网络传输统一采用大端规则。</p><p>如果你使用C/C++/Objective-C语言，有几个方法可以方便将本地字节序和网络字节序互相转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 网络字节序 -&gt; 本地字节序</span></span><br><span class="line">ntohs(x)    <span class="comment">// 转换short类型</span></span><br><span class="line">ntohl(x)    <span class="comment">// 转换long类型</span></span><br><span class="line">ntohll(x)   <span class="comment">// 转换long long类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地字节序 -&gt; 网络字节序</span></span><br><span class="line">htons(x)    <span class="comment">// 转换short类型</span></span><br><span class="line">htonl(x)    <span class="comment">// 转换long类型</span></span><br><span class="line">htonll(x)   <span class="comment">// 转换long long类型</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个int型整数，一般情况下占4个字节。那么这4个字节在内存中是怎么排列的呢？低内存地址存放的是低位字节还是高位子节呢？这就涉及到大端规则和小端规则。&lt;/p&gt;
&lt;p&gt;这是一个特别小特别基础的知识点，在大部分的日常开发中，我们并不需要理会大小端规则。但是当涉及到跨平台网络数据传输的时候，就需要考虑大小端规则了。&lt;/p&gt;
&lt;h3 id=&quot;大端规则（Big－Endian）&quot;&gt;&lt;a href=&quot;#大端规则（Big－Endian）&quot; class=&quot;headerlink&quot; title=&quot;大端规则（Big－Endian）&quot;&gt;&lt;/a&gt;大端规则（Big－Endian）&lt;/h3&gt;&lt;p&gt;将高位字节存储在低位地址，低位字节存储在高位地址，这种存储方式成为大端规则，也称为大端序。&lt;/p&gt;
&lt;p&gt;以&lt;code&gt;0xA1A2A3A4&lt;/code&gt;为例，使用大端规则，内存排列如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;低地址&amp;emsp;——&amp;gt;&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;——&amp;gt;&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;——&amp;gt;&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;——&amp;gt;&amp;emsp;高低地址&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;0xA1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0xA2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0xA3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0xA4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="http://jefferyfan.com/categories/Programing/"/>
    
    
      <category term="网络" scheme="http://jefferyfan.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="字节序" scheme="http://jefferyfan.com/tags/%E5%AD%97%E8%8A%82%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客自定义域名和部署到VPS</title>
    <link href="http://jefferyfan.com/2016/07/24/guide/hexo-custom-host-vps//"/>
    <id>http://jefferyfan.com/2016/07/24/guide/hexo-custom-host-vps//</id>
    <published>2016-07-24T07:47:40.000Z</published>
    <updated>2019-11-21T14:29:23.709Z</updated>
    
    <content type="html"><![CDATA[<p>很久之前，写过一篇文章<a href="/2015/07/22/guide/hexo-guide/">Hexo博客使用教程</a>，介绍大概如何使用Hexo新建一个博客并部署到github上。最近抽空买了个域名和VPS，把自己的博客部署到自己的VPS上。在此分享下，正在考虑购买域名和VPS的同学可以进来看看。另外，在文章结尾，推荐一款Markdown写作App。</p><p>如果大家对于自己部署博客有什么疑问，欢迎留言讨论。</p><p><strong>更新</strong><br>2016-07-25：<a href="#域名">将DNS管理从DNSPod迁移到CloudXNS上。</a>推荐大家使用CloudXNS。增加博客仓库介绍以及Markdown写作App推荐。</p><h3 id="VPS"><a href="#VPS" class="headerlink" title="VPS"></a>VPS</h3><p>VPS可以到搬瓦工或者DigitalOcean上购买。链接就不提供了，谷歌一下很容易找到。<br>搬瓦工3USD一个月，DO要5USD一个月。考虑到目前博客访问量比较少，搬瓦工最低配置都够用了，所以选择了搬瓦工。迟点等VPN到期之后准备迁移到DO上，当博客主机和自己架ShadowSocks。</p><p>对着阮一峰的博客 <a href="http://www.ruanyifeng.com/blog/2014/03/server_setup.html" target="_blank" rel="noopener">Linux服务器的初步配置流程</a> ，把VPS设置好。补充一些阮一峰博客没有提到的点：</p><ul><li>终端老是报错误：</li></ul><blockquote><p>locale: Cannot set LC_CTYPE to default locale: No such file or directory<br>locale: Cannot set LC_ALL to default locale: No such file or director</p></blockquote><a id="more"></a><p>解决方法是在<code>~/.profile</code>中添加<code>export LC_ALL=&quot;en_US.UTF-8&quot;</code></p><ul><li>安装和配置apache</li></ul><p>运行安装命令：<code>sudo apt-get install apache2</code><br>安装完成后修改<code>/etc/apache2/sites-enabled/000-default</code>站点配置文件。配置如下。把<code>/home/fanjie/blog</code>替换成自己的服务器根目录。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;VirtualHost *:80&gt;</span></span><br><span class="line">    <span class="attribute"><span class="nomarkup">DocumentRoot</span></span> /home/fanjie/blog</span><br><span class="line">    <span class="section">&lt;Directory /&gt;</span></span><br><span class="line">        <span class="attribute"><span class="nomarkup">Options</span></span> FollowSymLinks</span><br><span class="line">        <span class="attribute">AllowOverride</span> None</span><br><span class="line">    <span class="section">&lt;/Directory&gt;</span></span><br><span class="line">    <span class="section">&lt;Directory /home/fanjie/blog&gt;</span></span><br><span class="line">        <span class="attribute"><span class="nomarkup">Options</span></span> -Indexes FollowSymLinks MultiViews</span><br><span class="line">        <span class="attribute">AllowOverride</span> None</span><br><span class="line">        <span class="attribute"><span class="nomarkup">Order</span></span> allow,deny</span><br><span class="line">        <span class="attribute"><span class="nomarkup">allow</span></span> from <span class="literal">all</span></span><br><span class="line">    <span class="section">&lt;/Directory&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">LogLevel</span> warn</span><br><span class="line"></span><br><span class="line">    <span class="attribute">CustomLog</span> <span class="variable">$&#123;APACHE_LOG_DIR&#125;</span>/access.log combined</span><br><span class="line"><span class="section">&lt;/VirtualHost&gt;</span></span><br></pre></td></tr></table></figure><p>修改完配置后<code>sudo apachectl restart</code>重启apache。</p><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>在namesilo上购买域名，namesilo赠送WHOIS隐私保护。如果你选择其他域名提供商，纠结于要不要购买WHOIS隐私保护，可以看看我在V2EX上发起的讨论：<a href="http://v2ex.com/t/292986" target="_blank" rel="noopener">买域名有必要买隐私保护么？</a></p><p><del>DNS解析服务选择国内的DNSPod。</del> 域名解析服务使用<a href="https://www.cloudxns.net/" target="_blank" rel="noopener">CloudXNS</a>。相比于DNSPod，CloudXNS更新域名解析记录的速度非常快，并且域名解析速度也比DNSPod的快。不过以下的DNS解析记录设置还是基于DNSPod，CloudXNS类似。</p><ol><li><p>在namesile上修改域名服务商地址。在namesilo上修改了域名服务商，才能在DNSPod上配置域名解析记录。地址修改如下。<br><img src="/images/14693444963960.jpg" alt="域名解析地址接管设置示例"></p></li><li><p>在DNSPod上添加域名解析记录<br>先介绍下常用的两种域名解析记录。</p></li></ol><ul><li><p>A记录<br>A记录是将域名指向到IP地址。例如，将<code>duxevr.com</code>指向到VPS的IP地址，则需要新增一个A记录。</p></li><li><p>CNAME记录<br>将域名指向域名，别名。例如，我将<code>duxevr.com</code>指向我的VPS服务器，同时也希望<code>blog.duxevr.com</code>也指向VPS服务器，那么新增一个CNAME记录，将<code>blog.duxevr.com</code>指向<code>duxevr.com</code>。下次VPS迁移导致IP地址变化时，就只需要更改<code>duxevr.com</code>的A记录中的IP地址就行了，CNAME记录不需要更改。</p></li></ul><p>DNSPod上的解析记录，给大家参考下。<br><img src="/images/14693454532180.jpg" alt="DNS解析记录示例"></p><p><strong>主机记录（host）</strong>：二级域名的前缀。例如<code>blog.duxevr.com</code>的主机记录为<code>blog</code></p><p><strong>TTL（Time To Live）</strong>：域名解析记录的缓存的存活时间。一般来说，域名解析不经常变动的情况下，TTL设置大一点。当需要修改时，就TTL值改小一点，等带一段DNS的覆盖时间，再修改DNS解析记录。</p><h3 id="github博客重定向到duxevr-com"><a href="#github博客重定向到duxevr-com" class="headerlink" title="github博客重定向到duxevr.com"></a>github博客重定向到duxevr.com</h3><p>在source文件夹中新增加一个文件CNAME，文件内容为<code>blog.duxevr.com</code>。重新发布博客。当访问<code>http://jefferyfan.github.io</code>时，会被重定向至<code>http://blog.duxevr.com</code>。</p><h3 id="博客仓库结构"><a href="#博客仓库结构" class="headerlink" title="博客仓库结构"></a>博客仓库结构</h3><p>目前博客分为三个仓库。</p><ol><li>主题Next仓库：从源仓库fork出来，有一些地方做了小修改，定期merge源仓库。</li><li>博客配置仓库。主要是除主题、博客文章之外的不包含敏感信息的文件。</li><li>博客HTML代码仓库。其实就是一开始将博客挂在github的那个仓库。发布博客都是先发布到这个仓库，再到vps上执行<code>git pull</code>来更新。</li><li>博客文章使用dropbox同步。dropbox自动同步，不用每次修改之后都提交到git。</li></ol><p>不过，发布流程有些麻烦，需要先执行<code>hexo d</code>，再登陆到vps上执行<code>git pull</code>。写了个脚本，一键发布！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> `dirname <span class="variable">$0</span>`/..</span><br><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"\nDeploy to github"</span></span><br><span class="line">hexo d</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"\nDeploy to VPS"</span></span><br><span class="line">ssh vps <span class="string">"cd ~/blog;git checkout .;git clean -xdf;git pull"</span></span><br></pre></td></tr></table></figure><p>其中，最后一句中，大家需要把<code>vps</code>替换成自己的<code>.ssh/config</code>中VPS配置的Host；<code>~/blog</code>替换成VPS上的博客目录。</p><h3 id="Markdown写作App"><a href="#Markdown写作App" class="headerlink" title="Markdown写作App"></a>Markdown写作App</h3><p>推荐国内自由开发者完成的Markdown写作App－－<a href="http://zh.mweb.im/" target="_blank" rel="noopener">MWeb</a>，配合dropbox，写博客简直不能再完美。</p><p>有一点特别喜欢，图片粘贴后直接保存到设置好的文件夹。如果你的图片都放在source的子目录下，正好可以配合这个功能使用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久之前，写过一篇文章&lt;a href=&quot;/2015/07/22/guide/hexo-guide/&quot;&gt;Hexo博客使用教程&lt;/a&gt;，介绍大概如何使用Hexo新建一个博客并部署到github上。最近抽空买了个域名和VPS，把自己的博客部署到自己的VPS上。在此分享下，正在考虑购买域名和VPS的同学可以进来看看。另外，在文章结尾，推荐一款Markdown写作App。&lt;/p&gt;
&lt;p&gt;如果大家对于自己部署博客有什么疑问，欢迎留言讨论。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更新&lt;/strong&gt;&lt;br&gt;2016-07-25：&lt;a href=&quot;#域名&quot;&gt;将DNS管理从DNSPod迁移到CloudXNS上。&lt;/a&gt;推荐大家使用CloudXNS。增加博客仓库介绍以及Markdown写作App推荐。&lt;/p&gt;
&lt;h3 id=&quot;VPS&quot;&gt;&lt;a href=&quot;#VPS&quot; class=&quot;headerlink&quot; title=&quot;VPS&quot;&gt;&lt;/a&gt;VPS&lt;/h3&gt;&lt;p&gt;VPS可以到搬瓦工或者DigitalOcean上购买。链接就不提供了，谷歌一下很容易找到。&lt;br&gt;搬瓦工3USD一个月，DO要5USD一个月。考虑到目前博客访问量比较少，搬瓦工最低配置都够用了，所以选择了搬瓦工。迟点等VPN到期之后准备迁移到DO上，当博客主机和自己架ShadowSocks。&lt;/p&gt;
&lt;p&gt;对着阮一峰的博客 &lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/03/server_setup.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Linux服务器的初步配置流程&lt;/a&gt; ，把VPS设置好。补充一些阮一峰博客没有提到的点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;终端老是报错误：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;locale: Cannot set LC_CTYPE to default locale: No such file or directory&lt;br&gt;locale: Cannot set LC_ALL to default locale: No such file or director&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Guide" scheme="http://jefferyfan.com/categories/Guide/"/>
    
      <category term="Hexo" scheme="http://jefferyfan.com/categories/Guide/Hexo/"/>
    
    
      <category term="Guide" scheme="http://jefferyfan.com/tags/Guide/"/>
    
      <category term="Hexo" scheme="http://jefferyfan.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>广搜&amp;深搜算法和数独求解</title>
    <link href="http://jefferyfan.com/2016/07/16/programing/algorithm/dfs-gfs-sudo//"/>
    <id>http://jefferyfan.com/2016/07/16/programing/algorithm/dfs-gfs-sudo//</id>
    <published>2016-07-16T06:47:36.000Z</published>
    <updated>2019-11-21T14:34:00.137Z</updated>
    
    <content type="html"><![CDATA[<p>最近中了数独的毒，没事就玩数独。玩到后面，发现其实也没啥技术含量，主要是看眼力和尝试，有点没劲。还是写代码求解下数独吧，比较不费劲。</p><p>求解数独应用到广度优先搜索和深度优先搜索算法。先简单介绍下这两个算法。最后在文末提供一个求解数据的demo。<br>数独所有可能的解法可以组成多叉树，遍历每一个节点，判断该节点是否是正解。</p><a id="more"></a><h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>利用队列来实现，遍历队列中的节点，遍历节点的同时，需要将节点的子节点也添加到队列中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enqueue root</span><br><span class="line">while queue is not empty:</span><br><span class="line">    dequeue as node</span><br><span class="line">    enqueue node&apos;s subnode</span><br></pre></td></tr></table></figure><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>利用栈来实现，从根节点出发，发现有子节点未访问过则将子节点入栈。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">push root</span><br><span class="line">while stack is not empty:</span><br><span class="line">    if left child of stack.top has not been visited:</span><br><span class="line">        set left child visited</span><br><span class="line">        push left child</span><br><span class="line">    else if right child of stack.top has not been visited:</span><br><span class="line">        set right child visited</span><br><span class="line">        push right child</span><br><span class="line">    else:</span><br><span class="line">        pop stack</span><br></pre></td></tr></table></figure><h3 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h3><p>数独你好 数独再见 👋👋</p><style type="text/css">.sudo-panel{max-width:340px}.sudo-panel input{border:0;width:100%;height:100%;background-color:rgba(255,255,255,0);text-align:center}.sudo-panel.sudo-disable input{pointer-events:none}.sudo-panel-td{padding:0;background-color:#fff}.sudo-panel-td-sep{padding:0;width:2px;background-color:#ddd}.sudo-panel-tr-sep{width:100%;height:1px;background-color:#ddd}.sudo-panel-tr-sep td{border:0;padding:0;height:2px;background-color:#ddd}.sudo-btn{border-radius:10px;width:80px}</style><table class="sudo-panel" id='sudo-panel'><tbody>   <tr>        <td class="sudo-panel-td"><input></input></td>      <td class="sudo-panel-td"><input value='9'></input></td><td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td-sep"></td>       <td class="sudo-panel-td"><input value='5'></input></td><td class="sudo-panel-td"><input></input></td>      <td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td-sep"></td><td class="sudo-panel-td"><input></input></td>     <td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td"><input></input></td>    </tr><tr>       <td class="sudo-panel-td"><input></input></td>      <td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td"><input value='5'></input></td><td class="sudo-panel-td-sep"></td>       <td class="sudo-panel-td"><input value='4'></input></td><td class="sudo-panel-td"><input></input></td>      <td class="sudo-panel-td"><input value='7'></input></td><td class="sudo-panel-td-sep"></td><td class="sudo-panel-td"><input></input></td>       <td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td"><input></input></td>    </tr><tr>       <td class="sudo-panel-td"><input value='7'></input></td>        <td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td-sep"></td>     <td class="sudo-panel-td"><input value='9'></input></td><td class="sudo-panel-td"><input value='8'></input></td>        <td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td-sep"></td><td class="sudo-panel-td"><input></input></td>     <td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td"><input></input></td>    </tr><tr class="sudo-panel-tr-sep"><td /><td /><td /><td /><td /><td /><td /><td /><td /><td /><td /></tr><tr>      <td class="sudo-panel-td"><input></input></td>      <td class="sudo-panel-td"><input value='6'></input></td><td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td-sep"></td>       <td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td"><input></input></td>        <td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td-sep"></td><td class="sudo-panel-td"><input value='5'></input></td>       <td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td"><input value='2'></input></td>  </tr><tr>       <td class="sudo-panel-td"><input  value='3'></input></td>       <td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td-sep"></td>     <td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td"><input></input></td>        <td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td-sep"></td><td class="sudo-panel-td"><input value='8'></input></td>       <td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td"><input value='4'></input></td>  </tr><tr>       <td class="sudo-panel-td"><input></input></td>      <td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td-sep"></td>     <td class="sudo-panel-td"><input value='8'></input></td><td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td"><input value='4'></input></td><td class="sudo-panel-td-sep"></td><td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td"><input></input></td>       <td class="sudo-panel-td"><input></input></td>  </tr><tr class="sudo-panel-tr-sep"><td /><td /><td /><td /><td /><td /><td /><td /><td /><td /><td /></tr><tr>      <td class="sudo-panel-td"><input value='6'></input></td>        <td class="sudo-panel-td"><input value='2'></input></td><td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td-sep"></td>       <td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td"><input></input></td>        <td class="sudo-panel-td"><input  value='8'></input></td><td class="sudo-panel-td-sep"></td><td class="sudo-panel-td"><input></input></td>      <td class="sudo-panel-td"><input value='9'></input></td><td class="sudo-panel-td"><input></input></td>  </tr><tr>       <td class="sudo-panel-td"><input value='8'></input></td>        <td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td-sep"></td>     <td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td"><input></input></td>        <td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td-sep"></td><td class="sudo-panel-td"><input></input></td>     <td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td"><input></input></td>    </tr><tr>       <td class="sudo-panel-td"><input></input></td>      <td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td"><input value='7'></input></td><td class="sudo-panel-td-sep"></td>       <td class="sudo-panel-td"><input value='6'></input></td><td class="sudo-panel-td"><input value='3'></input></td>        <td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td-sep"></td><td class="sudo-panel-td"><input value='2'></input></td>       <td class="sudo-panel-td"><input></input></td><td class="sudo-panel-td"><input></input></td>    </tr></tbody></table><button class="sudo-btn" id='sudo-btn' onclick="startSudo()">求解</button><button class="sudo-btn" onclick="resetTable()">清除</button><script type="text/javascript" src="/assets/sudo/sudo.js.txt"></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近中了数独的毒，没事就玩数独。玩到后面，发现其实也没啥技术含量，主要是看眼力和尝试，有点没劲。还是写代码求解下数独吧，比较不费劲。&lt;/p&gt;
&lt;p&gt;求解数独应用到广度优先搜索和深度优先搜索算法。先简单介绍下这两个算法。最后在文末提供一个求解数据的demo。&lt;br&gt;数独所有可能的解法可以组成多叉树，遍历每一个节点，判断该节点是否是正解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="http://jefferyfan.com/categories/Programing/"/>
    
      <category term="Algorithm" scheme="http://jefferyfan.com/categories/Programing/Algorithm/"/>
    
    
      <category term="数独" scheme="http://jefferyfan.com/tags/%E6%95%B0%E7%8B%AC/"/>
    
      <category term="Algorithm" scheme="http://jefferyfan.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>NSString踩坑</title>
    <link href="http://jefferyfan.com/2016/07/14/programing/iOS/nsstring-trap//"/>
    <id>http://jefferyfan.com/2016/07/14/programing/iOS/nsstring-trap//</id>
    <published>2016-07-14T14:22:00.000Z</published>
    <updated>2019-11-21T14:32:56.584Z</updated>
    
    <content type="html"><![CDATA[<p>NSString是最最常用的类之一。但是时不时还是会被NSString坑到。在这里记录两个我遇到的坑。</p><h3 id="length"><a href="#length" class="headerlink" title="length"></a>length</h3><p>length方法每天用来用去竟然也有坑！！？不信的话看看以下的代码。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@"您来啦啦"</span>;</span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithBytes:str.UTF8String length:[str length]];</span><br><span class="line"><span class="built_in">NSString</span> *str2 = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str2);</span><br></pre></td></tr></table></figure><p>最后输出什么呢？当然不是<code>您来啦啦</code>，而是<code>(null)</code>。str2为nil。原因是str中包含中文，UTF8编码下，中文占多个byte。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"lenght: %zd"</span>, [str length]);                            <span class="comment">// lenght: 4</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"length of UTF8String: %ld"</span>, strlen(str.UTF8String));    <span class="comment">// length of UTF8String: 12</span></span><br></pre></td></tr></table></figure><p>正确的写法如下:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@"您来啦啦"</span>;</span><br><span class="line"><span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithBytes:str.UTF8String length:[str lengthOfBytesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>]];</span><br><span class="line"><span class="built_in">NSString</span> *str2 = [[<span class="built_in">NSString</span> alloc] initWithData:data encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, str2); <span class="comment">// 您来啦啦</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="getCString-maxLength-encoding"><a href="#getCString-maxLength-encoding" class="headerlink" title="getCString:maxLength:encoding:"></a>getCString:maxLength:encoding:</h3><p>如果从方法的名字上理解，是将NSString的UTF8String拷贝到bytes中，长度不超过maxLength，如果UTF8String的长度大于maxLength，则取前面的maxLength长度的串。但是这么理解，只理解对了一半。</p><p><strong>如果maxLength &lt; lengthOfBytesUsingEncoding获取的长度，方法不会将数据拷贝到bytes中，返回NO</strong></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> cstr[<span class="number">5</span>] = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="built_in">BOOL</span> ret = [<span class="string">@"uvwxyz"</span> getCString:cstr maxLength:<span class="keyword">sizeof</span>(cstr) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"ret:%@  %s"</span>, ret ? <span class="string">@"YES"</span> : <span class="string">@"NO"</span>, cstr);</span><br><span class="line">ret = [<span class="string">@"xyz"</span> getCString:cstr maxLength:<span class="keyword">sizeof</span>(cstr) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"ret:%@  %s"</span>, ret ? <span class="string">@"YES"</span> : <span class="string">@"NO"</span>, cstr);</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret:NO  abcd</span><br><span class="line">ret:YES  xyz</span><br></pre></td></tr></table></figure><p>结果显而易见。不再赘述。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NSString是最最常用的类之一。但是时不时还是会被NSString坑到。在这里记录两个我遇到的坑。&lt;/p&gt;
&lt;h3 id=&quot;length&quot;&gt;&lt;a href=&quot;#length&quot; class=&quot;headerlink&quot; title=&quot;length&quot;&gt;&lt;/a&gt;length&lt;/h3&gt;&lt;p&gt;length方法每天用来用去竟然也有坑！！？不信的话看看以下的代码。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *str = &lt;span class=&quot;string&quot;&gt;@&quot;您来啦啦&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSData&lt;/span&gt; *data = [&lt;span class=&quot;built_in&quot;&gt;NSData&lt;/span&gt; dataWithBytes:str.UTF8String length:[str length]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *str2 = [[&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; alloc] initWithData:data encoding:&lt;span class=&quot;built_in&quot;&gt;NSUTF8StringEncoding&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, str2);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;最后输出什么呢？当然不是&lt;code&gt;您来啦啦&lt;/code&gt;，而是&lt;code&gt;(null)&lt;/code&gt;。str2为nil。原因是str中包含中文，UTF8编码下，中文占多个byte。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;lenght: %zd&quot;&lt;/span&gt;, [str length]);                            &lt;span class=&quot;comment&quot;&gt;// lenght: 4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;length of UTF8String: %ld&quot;&lt;/span&gt;, strlen(str.UTF8String));    &lt;span class=&quot;comment&quot;&gt;// length of UTF8String: 12&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;正确的写法如下:&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *str = &lt;span class=&quot;string&quot;&gt;@&quot;您来啦啦&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSData&lt;/span&gt; *data = [&lt;span class=&quot;built_in&quot;&gt;NSData&lt;/span&gt; dataWithBytes:str.UTF8String length:[str lengthOfBytesUsingEncoding:&lt;span class=&quot;built_in&quot;&gt;NSUTF8StringEncoding&lt;/span&gt;]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *str2 = [[&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; alloc] initWithData:data encoding:&lt;span class=&quot;built_in&quot;&gt;NSUTF8StringEncoding&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;%@&quot;&lt;/span&gt;, str2); &lt;span class=&quot;comment&quot;&gt;// 您来啦啦&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="http://jefferyfan.com/categories/Programing/"/>
    
      <category term="iOS" scheme="http://jefferyfan.com/categories/Programing/iOS/"/>
    
    
      <category term="iOS" scheme="http://jefferyfan.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://jefferyfan.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>利用mask实现icon颜色变换</title>
    <link href="http://jefferyfan.com/2016/07/13/programing/iOS/ios-image-mask//"/>
    <id>http://jefferyfan.com/2016/07/13/programing/iOS/ios-image-mask//</id>
    <published>2016-07-13T15:26:00.000Z</published>
    <updated>2019-11-21T14:32:47.847Z</updated>
    
    <content type="html"><![CDATA[<p>假设你有一张图片如下：<br><img src="/images/ios-image-mask/apple@2x.png" alt=""></p><p>在不同的场景下你需要将这个图标显示成不同的颜色，特别是对于有皮肤功能的app来说，这种场景相对多一些。效果如下：<br><img src="/images/ios-image-mask/result.png" alt=""></p><p>该如何实现呢？本文提供三种实现方法。如果各位看官有更好的实现方法，欢迎留言讨论。</p><a id="more"></a><p><a href="https://github.com/JefferyFan/ImageMaskSample" target="_blank" rel="noopener">SampleCode on Github</a></p><h3 id="方法一：利用tintColor和renderingMode"><a href="#方法一：利用tintColor和renderingMode" class="headerlink" title="方法一：利用tintColor和renderingMode"></a>方法一：利用tintColor和renderingMode</h3><p>UIImage中有一个属性renderingMode，其中一个可能的取值为：UIImageRenderingModeAlwaysTemplate。官方文档中指出：</p><blockquote><p><strong>UIImageRenderingModeAlwaysTemplate</strong><br>Always draw the image as a template image, ignoring its color information.</p></blockquote><p>通俗地讲，当UIImage的renderingMode为UIImageRenderingModeAlwaysTemplate时，渲染时不再按照原始图片中的颜色进行渲染，颜色的取值统一取view中tintColor。利用这个特性，则就可以实现我们想要的效果啦，代码如下。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImageView</span> *)imageViewWithSourceImage:(<span class="built_in">UIImage</span> *)image tintColor:(<span class="built_in">UIColor</span> *)color</span><br><span class="line">&#123;</span><br><span class="line">    image = [image imageWithRenderingMode:<span class="built_in">UIImageRenderingModeAlwaysTemplate</span>];</span><br><span class="line">    <span class="built_in">CGRect</span> frame = (<span class="built_in">CGRect</span>)&#123;<span class="built_in">CGPointZero</span>, image.size&#125;;;</span><br><span class="line">    <span class="built_in">UIImageView</span> *imageView = [[[<span class="built_in">UIImageView</span> alloc] initWithFrame:frame] autorelease];</span><br><span class="line">    imageView.tintColor = color;</span><br><span class="line">    imageView.image = image;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imageView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：利用layer-mask"><a href="#方法二：利用layer-mask" class="headerlink" title="方法二：利用layer.mask"></a>方法二：利用layer.mask</h3><p>CALayer有一个属性mask。对于每一个像素点的alpha值，可以用这个公式计算得出：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content.alpha = originContent.alpha * mask.alpha;</span><br></pre></td></tr></table></figure><p>利用mask和设置backgroundColor为我们想要的颜色，同样也可以实现。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImageView</span> *)imageViewWithSourceImage:(<span class="built_in">UIImage</span> *)image layerColor:(<span class="built_in">UIColor</span> *)color</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> frame = (<span class="built_in">CGRect</span>)&#123;<span class="built_in">CGPointZero</span>, image.size&#125;;;</span><br><span class="line">    <span class="built_in">UIImageView</span> *imageView = [[[<span class="built_in">UIImageView</span> alloc] initWithFrame:frame] autorelease];</span><br><span class="line">    <span class="built_in">CALayer</span> *layer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">    layer.frame = imageView.bounds;</span><br><span class="line">    layer.contents = (<span class="keyword">id</span>)image.CGImage;</span><br><span class="line">    imageView.layer.mask = layer;</span><br><span class="line">    imageView.backgroundColor = color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imageView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，<strong>不要忘记设置mask的frame</strong>。</p><h3 id="方法三：CoreGraphics绘制"><a href="#方法三：CoreGraphics绘制" class="headerlink" title="方法三：CoreGraphics绘制"></a>方法三：CoreGraphics绘制</h3><p>主要利用CGContextClipToMask方法，将填充区域限制在mask的范围内，再填充颜色即可。<br>需要注意的是，CG的坐标系和UIKit的坐标系是不同的。UIKit以左上角为原点；CG以左下角为原点，y轴向上。绘制的时候需要注意坐标轴变换。<br>其次，要注意image的scale处理。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UIImageView</span> *)imageViewWithSourceImage:(<span class="built_in">UIImage</span> *)image fillColor:(<span class="built_in">UIColor</span> *)color</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGRect</span> rect = (<span class="built_in">CGRect</span>)&#123;<span class="built_in">CGPointZero</span>, image.size&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(rect.size, <span class="literal">NO</span>, image.scale);</span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于坐标系不同，需要翻转Y坐标。如果不翻转Y坐标，则image上下颠倒。</span></span><br><span class="line">    <span class="built_in">CGContextTranslateCTM</span>(context, <span class="number">0</span>, rect.size.height);</span><br><span class="line">    <span class="built_in">CGContextScaleCTM</span>(context, <span class="number">1.</span>f, <span class="number">-1.</span>f);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将后续的操作都限制到mask范围内</span></span><br><span class="line">    <span class="built_in">CGContextClipToMask</span>(context, rect, image.CGImage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充颜色</span></span><br><span class="line">    <span class="built_in">CGContextSetFillColorWithColor</span>(context, color.CGColor);</span><br><span class="line">    <span class="built_in">CGContextFillRect</span>(context, rect);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIImage</span> *sourceImage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">    <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UIImageView</span> *imageView = [[[<span class="built_in">UIImageView</span> alloc] initWithFrame:rect] autorelease];</span><br><span class="line">    imageView.image = sourceImage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imageView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;假设你有一张图片如下：&lt;br&gt;&lt;img src=&quot;/images/ios-image-mask/apple@2x.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在不同的场景下你需要将这个图标显示成不同的颜色，特别是对于有皮肤功能的app来说，这种场景相对多一些。效果如下：&lt;br&gt;&lt;img src=&quot;/images/ios-image-mask/result.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;该如何实现呢？本文提供三种实现方法。如果各位看官有更好的实现方法，欢迎留言讨论。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="http://jefferyfan.com/categories/Programing/"/>
    
      <category term="iOS" scheme="http://jefferyfan.com/categories/Programing/iOS/"/>
    
    
      <category term="iOS" scheme="http://jefferyfan.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://jefferyfan.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>理解CATransaction</title>
    <link href="http://jefferyfan.com/2016/06/27/programing/iOS/CATransaction//"/>
    <id>http://jefferyfan.com/2016/06/27/programing/iOS/CATransaction//</id>
    <published>2016-06-27T07:49:50.000Z</published>
    <updated>2019-11-21T14:33:07.066Z</updated>
    
    <content type="html"><![CDATA[<p>写动画的时候偶尔会用到CATransaction来设置一些动画参数。有时候，调用一个接口做一些动画，但是接口并没有提供一个参数completionBlock，也可以利用CATransaction来添加completionBlock而不用改到别人的接口。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">CATransaction</span> begin];</span><br><span class="line">[<span class="built_in">CATransaction</span> setCompletionBlock:^&#123;</span><br><span class="line">    <span class="comment">//complete block</span></span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// do animation</span></span><br><span class="line">[<span class="built_in">CATransaction</span> commit];</span><br></pre></td></tr></table></figure><p>⚠️  <a href="/2016/11/13/iOS/CATransaction-trap/">CATransaction 踩坑：completion block 没有立即调用</a></p><p>只知道可以这么用，但是CATransaction到底是一个什么东西呢？</p><h3 id="CATransaction"><a href="#CATransaction" class="headerlink" title="CATransaction"></a>CATransaction</h3><p><a href="https://developer.apple.com/reference/quartzcore/catransaction?language=objc" target="_blank" rel="noopener">官方文档</a> 如是说：</p><blockquote><p>CATransaction is the Core Animation mechanism for batching multiple layer-tree operations into atomic updates to the render tree. Every modification to a layer tree must be part of a transaction. Nested transactions are supported.</p></blockquote><p>CATransaction是事务，用于批量提交多个对layer-tree的操作，并且是原子性的。所有对layer-tree的修改都必须包含在事务内。事务可以嵌套。</p><a id="more"></a><h3 id="嵌套事务"><a href="#嵌套事务" class="headerlink" title="嵌套事务"></a>嵌套事务</h3><p>事务允许嵌套。但是嵌套在内层的事务不会立即commit，会在最外层的事务结束后统一commit。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doUIOperation</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">    <span class="comment">// UI operations here</span></span><br><span class="line">    [<span class="keyword">self</span> doMoreUIOperation];</span><br><span class="line">    [<span class="built_in">CATransaction</span> commit];     <span class="comment">// 最外层事务</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)doMoreUIOperation</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">    <span class="comment">// more UI operations here</span></span><br><span class="line">    [<span class="built_in">CATransaction</span> commit];     <span class="comment">// 嵌套事务，等待外层事务commit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="隐式CATransaction"><a href="#隐式CATransaction" class="headerlink" title="隐式CATransaction"></a>隐式CATransaction</h3><p>所有对layer-tree的操作都必须处于事务。修改UIView的属性最终也是修改到了layer-tree。当我们改动到layer-tree时，如果当前没有显式创建过CATransaction，则系统会创建一个隐式的CATransaction，这个隐式CATransaction会在RunLoop结束后commit。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doUIOperation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> redColor]; <span class="comment">// 系统自动创建隐式CATransaction</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="显式CATransaction"><a href="#显式CATransaction" class="headerlink" title="显式CATransaction"></a>显式CATransaction</h3><p>一般情况下，显式创建CATransaction是为了设置动画参数。但是，CATransaction还有另外一种用处。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doUIOperation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;&#125;  <span class="comment">// 暴力模拟耗时操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，背景色没有更新为红色。<br>当我们更新了UI，紧接着做一些耗时的操作，这个时候UI的更新必须要等到耗时操作结束。有几个方案可以解决这个UI更新不及时的问题。</p><ul><li><p>方案一<br>最根本的，当然是不应该在主线程做过多耗时的操作，应该尽量将一些耗时操作转移到子线程去完成。优化了主线程的耗时操作之后，自然就不会有UI更新不及时的问题了。</p></li><li><p>方案二<br>有时候有一些耗时操作必须在主线程完成，例如App启动，很多业务都需要进行初始化，这个时候UI更新就会出现不及时的情况。可以通过显示创建CATransaction来解决。</p></li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doUIOperation</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;&#125;  <span class="comment">// 暴力模拟耗时操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，凡事都有个但是。如果在创建显式的CATransaction之前有修改View，系统会自动创建隐式的CATransaction。那么再创建显式的CATransaction就是嵌套在隐式CATransaction中的事务了，需要等到RunLoop结束隐式CATransaction提交之后UI才会刷新。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doUIOperation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> blueColor];</span><br><span class="line">    [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> redColor];</span><br><span class="line">    [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;&#125;  <span class="comment">// 暴力模拟耗时操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，背景色没有更新为红色。由此可见，这个方案并不稳定。可能这个时候解决了，后面迭代开发的时候又失效。</p><ul><li>方案三<br>在更新了UI和耗时操作之前调用<code>[CATransaction flush]</code>。<br>这个方案非常不建议使用。<code>[CATransaction flush]</code>在RunLoop结束后由系统调用。提前调用有以下缺点：<ul><li>UI更新效率低</li><li>UI显示异常。如果当前正在做一些动画（如：旋转屏幕）过程中调用了<code>[CATransaction flush]</code>可能会引起UI异常。</li></ul></li></ul><p>以上，方案二不能稳定解决问题，方案三可能会引入副作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写动画的时候偶尔会用到CATransaction来设置一些动画参数。有时候，调用一个接口做一些动画，但是接口并没有提供一个参数completionBlock，也可以利用CATransaction来添加completionBlock而不用改到别人的接口。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;built_in&quot;&gt;CATransaction&lt;/span&gt; begin];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;built_in&quot;&gt;CATransaction&lt;/span&gt; setCompletionBlock:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//complete block&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// do animation&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;span class=&quot;built_in&quot;&gt;CATransaction&lt;/span&gt; commit];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;⚠️  &lt;a href=&quot;/2016/11/13/iOS/CATransaction-trap/&quot;&gt;CATransaction 踩坑：completion block 没有立即调用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;只知道可以这么用，但是CATransaction到底是一个什么东西呢？&lt;/p&gt;
&lt;h3 id=&quot;CATransaction&quot;&gt;&lt;a href=&quot;#CATransaction&quot; class=&quot;headerlink&quot; title=&quot;CATransaction&quot;&gt;&lt;/a&gt;CATransaction&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://developer.apple.com/reference/quartzcore/catransaction?language=objc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt; 如是说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;CATransaction is the Core Animation mechanism for batching multiple layer-tree operations into atomic updates to the render tree. Every modification to a layer tree must be part of a transaction. Nested transactions are supported.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CATransaction是事务，用于批量提交多个对layer-tree的操作，并且是原子性的。所有对layer-tree的修改都必须包含在事务内。事务可以嵌套。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="http://jefferyfan.com/categories/Programing/"/>
    
      <category term="iOS" scheme="http://jefferyfan.com/categories/Programing/iOS/"/>
    
    
      <category term="iOS" scheme="http://jefferyfan.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://jefferyfan.com/tags/Objective-C/"/>
    
      <category term="CATransaction" scheme="http://jefferyfan.com/tags/CATransaction/"/>
    
  </entry>
  
  <entry>
    <title>iOS教程（二）消息发送</title>
    <link href="http://jefferyfan.com/2016/01/24/programing/iOS/tutorial/02MethodResolve//"/>
    <id>http://jefferyfan.com/2016/01/24/programing/iOS/tutorial/02MethodResolve//</id>
    <published>2016-01-24T05:24:16.000Z</published>
    <updated>2019-11-21T14:31:41.417Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，Objective-C 中的方法调用跟C语言中的函数调用很不一样，OC 中的方法调用称为消息发送。例如，<code>[self callMethod]</code>称为对 self 对象发送<code>callMethod</code>的消息。正是这种消息发送机制，让 OC 有一个很神奇的特性，对<code>nil</code>进行方法调用不会导致崩溃。</p><p>本文粗略讲述下OC的方法调用，介绍下在 OC 中通过 selector 的形式调用方法，实际上都发生了什么。</p><h3 id="performSelector"><a href="#performSelector" class="headerlink" title="performSelector"></a>performSelector</h3><p>先看下 OC runtime 的源码对于 performSelector 的实现。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)sel withObject:(<span class="keyword">id</span>)obj1 withObject:(<span class="keyword">id</span>)obj2 &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>, <span class="keyword">id</span>))objc_msgSend)(<span class="keyword">self</span>, sel, obj1, obj2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来 performSelector 的实现如此简单，那么完全可以自己对 NSObject 做一个扩展，支持调用需要三个参数的 selector。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)performSelector:(SEL)sel withObject:(<span class="keyword">id</span>)obj1 withObject:(<span class="keyword">id</span>)obj2 withObject:(<span class="keyword">id</span>)obj3 &#123;</span><br><span class="line">    <span class="keyword">if</span> (!sel) [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">id</span>(*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>, <span class="keyword">id</span>, <span class="keyword">id</span>))objc_msgSend)(<span class="keyword">self</span>, sel, obj1, obj2, obj3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息发送流程"><a href="#消息发送流程" class="headerlink" title="消息发送流程"></a>消息发送流程</h3><p><code>performSelector</code>实际上是调用了<code>objc_msgSend</code>。<code>objc_msgSend</code>并没有源码可以给我们参考。不过我们看下<code>NSObject</code>中的几个跟消息发送相关的方法。</p><a id="more"></a><ul><li><p><code>+ (BOOL)resolveClassMethod:(SEL)sel</code>和<code>+ (BOOL)resolveInstanceMethod:(SEL)sel</code><br>在方法中，允许通过调用<code>class_addMethod</code>来动态的为<code>sel</code>添加一个实现。如果动态添加了实现，则返回YES。</p></li><li><p><code>- (id)forwardingTargetForSelector:(SEL)aSelector</code><br>当从<code>self</code>中找不到<code>aSelector</code>对应的实现时，调用此方法。此方法如果返回一个非<code>nil</code>且非<code>self</code>的对象，则会把该对象作为新的消息接受者。在该对象中寻找对应的实现。</p></li><li><p><code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector</code><br>返回<code>aSelector</code>的方法签名。方法签名和 Type Encoding 会另开一篇博客来介绍。</p></li><li><p><code>- (void)forwardInvocation:(NSInvocation *)anInvocation</code><br>当对<code>self</code>发送一个<code>unrecoginzed</code>的消息时，会创建一个<code>NSInvocation</code>，并调用这个方法。允许在这个方法中，通过<code>[anInvocation invokeWithTarget:otherSelf];</code>的方式进行消息转发。</p></li></ul><p>具体这几个方法之间的关系和调用顺序如下：<br><img src="/images/method-resolve.jpg" alt="method-resolve"></p><h3 id="其他形式"><a href="#其他形式" class="headerlink" title="其他形式"></a>其他形式</h3><p>前面的介绍中，都是以 performSelector 来执行为基础的。那么，直接方法调用的流程跟与 selector 调用是一样的吗？</p><p>假设有这个一个方法：<code>- (void)methodDirectInvoke:(int)param;</code>。那么通过clang命令，<code>[self methodDirectInvoke:1];</code>被转化为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((void (*)(id, SEL, int))(void *)objc_msgSend)((id)self, sel_registerName(&quot;methodDirectInvoke:&quot;), 1);</span><br></pre></td></tr></table></figure><p>由此可见，所有的方法调用都会被转化为<code>objc_msgSend</code>消息发送，因此直接的方法调用流程与<code>selector</code>调用是一致的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，Objective-C 中的方法调用跟C语言中的函数调用很不一样，OC 中的方法调用称为消息发送。例如，&lt;code&gt;[self callMethod]&lt;/code&gt;称为对 self 对象发送&lt;code&gt;callMethod&lt;/code&gt;的消息。正是这种消息发送机制，让 OC 有一个很神奇的特性，对&lt;code&gt;nil&lt;/code&gt;进行方法调用不会导致崩溃。&lt;/p&gt;
&lt;p&gt;本文粗略讲述下OC的方法调用，介绍下在 OC 中通过 selector 的形式调用方法，实际上都发生了什么。&lt;/p&gt;
&lt;h3 id=&quot;performSelector&quot;&gt;&lt;a href=&quot;#performSelector&quot; class=&quot;headerlink&quot; title=&quot;performSelector&quot;&gt;&lt;/a&gt;performSelector&lt;/h3&gt;&lt;p&gt;先看下 OC runtime 的源码对于 performSelector 的实现。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)performSelector:(SEL)sel withObject:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)obj1 withObject:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)obj2 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!sel) [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; doesNotRecognizeSelector:sel];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ((&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;(*)(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, SEL, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;))objc_msgSend)(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, sel, obj1, obj2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;原来 performSelector 的实现如此简单，那么完全可以自己对 NSObject 做一个扩展，支持调用需要三个参数的 selector。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)performSelector:(SEL)sel withObject:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)obj1 withObject:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)obj2 withObject:(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;)obj3 &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!sel) [&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt; doesNotRecognizeSelector:sel];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ((&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;(*)(&lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, SEL, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;id&lt;/span&gt;))objc_msgSend)(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, sel, obj1, obj2, obj3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;消息发送流程&quot;&gt;&lt;a href=&quot;#消息发送流程&quot; class=&quot;headerlink&quot; title=&quot;消息发送流程&quot;&gt;&lt;/a&gt;消息发送流程&lt;/h3&gt;&lt;p&gt;&lt;code&gt;performSelector&lt;/code&gt;实际上是调用了&lt;code&gt;objc_msgSend&lt;/code&gt;。&lt;code&gt;objc_msgSend&lt;/code&gt;并没有源码可以给我们参考。不过我们看下&lt;code&gt;NSObject&lt;/code&gt;中的几个跟消息发送相关的方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="http://jefferyfan.com/categories/Programing/"/>
    
      <category term="iOS" scheme="http://jefferyfan.com/categories/Programing/iOS/"/>
    
    
      <category term="iOS" scheme="http://jefferyfan.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://jefferyfan.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>UITableView reloadSections引发的崩溃</title>
    <link href="http://jefferyfan.com/2016/01/10/programing/iOS/reloadSections//"/>
    <id>http://jefferyfan.com/2016/01/10/programing/iOS/reloadSections//</id>
    <published>2016-01-10T13:53:36.000Z</published>
    <updated>2019-11-21T14:32:39.229Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS的开发中，UITableView是最经常用到的UI组件之一。然而，UITableView却非常容易引起「NSInternalInconsistencyException（数据不一致）」的崩溃。其中，调用reloadSections时，一不留神就会引发崩溃。</p><h3 id="reloadSections简介"><a href="#reloadSections简介" class="headerlink" title="reloadSections简介"></a>reloadSections简介</h3><p>当UITableView的数据源变化时，通常会调用<code>reloadData</code>或者<code>reloadSections:withRowAnimation:</code>通知UITableView刷新UI。单从UI角度考虑，两者最大的区别就是<code>reloadData</code>没有动画。所以，一般为用户体验考虑，我一般使用<code>reloadSections:withRowAnimation:</code>。</p><h3 id="reloadSections引发崩溃"><a href="#reloadSections引发崩溃" class="headerlink" title="reloadSections引发崩溃"></a>reloadSections引发崩溃</h3><p>调用<code>reloadSections:withRowAnimation:</code>方法时，UITableView会校验其他section，如果发现UITableView内记录的某section的row的数量和<code>[dataSource tableView:numberOfRowsInSection]</code>返回的不一致时，抛出<code>NSInternalInconsistencyException</code>异常。</p><a id="more"></a><h3 id="崩溃案例"><a href="#崩溃案例" class="headerlink" title="崩溃案例"></a>崩溃案例</h3><p>其实reloadSections引起崩溃的原因非常简单。但是虽然简单，还是很容易在不经意间引起崩溃。那么继续来看下具体的案例，加深下印象。</p><ul><li>案例一：延迟reload场景。<br>出于业务的某些需要，当SectionOne的数据源个数变化时，延迟刷新TableView。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)onSectionOneUpdate</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(reloadSectionOne) withObject:<span class="literal">nil</span> afterDelay:<span class="number">0.1</span>f];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)reloadSectionOne</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.tableView reloadSections:[<span class="built_in">NSIndexSet</span> indexSetWithIndex:<span class="number">0</span>] withRowAnimation:<span class="built_in">UITableViewRowAnimationAutomatic</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在这0.1秒当中，对其他section进行reload则会引发崩溃。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)reloadSectionTwo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// It will crash.</span></span><br><span class="line">    [<span class="keyword">self</span>.tableView reloadSections:[<span class="built_in">NSIndexSet</span> indexSetWithIndex:<span class="number">1</span>] withRowAnimation:<span class="built_in">UITableViewRowAnimationAutomatic</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>崩溃的原因自然是因为SectionOne的数据源个数和UITableView中的不一致导致。要解决这个场景的崩溃其实也很简单。用一个<code>NSMutableIndexSet</code>变量记录需要reload的section。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)onSectionOneUpdate</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.sectionNeedReload addIndex:<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// delay reload</span></span><br><span class="line">    [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(reloadSections:) withObject:<span class="literal">nil</span> afterDelay:<span class="number">0.1</span>f];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)onSectionTwoUpdate</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span>.sectionNeedReload addIndex:<span class="number">1</span>];</span><br><span class="line">    [<span class="keyword">self</span> reloadPartSection];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)reloadSections</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.sectionNeedReload count])</span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="keyword">self</span>.tableView reloadSections:<span class="keyword">self</span>.sectionNeedReload withRowAnimation:<span class="built_in">UITableViewRowAnimationAutomatic</span>];</span><br><span class="line">        [<span class="keyword">self</span>.sectionNeedReload removeAllIndexes];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>案例二：Section的numberOfRow依赖于其他Section<br>UITableView有两个Section。整个UITableView都没有数据时，需要在section0中显示一个特殊的<code>EmptyCell</code>，提示用户当前UITableView没有数据。那么先看下<code>[dataSource tableView:numberOfRowsInSection:]</code>的实现。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dataSource</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (section == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> dataCountInSection:<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; [<span class="keyword">self</span> dataCountInSection:<span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> dataCountInSection:section];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么当程序按照以下步骤运行时，就必然崩溃。</p><ol><li>UITableView没有数据。section0中有一个EmptyCell。</li><li>secton1数据源增加一个item</li><li>调用reloadSections，只刷新section1。程序崩溃。</li></ol><p>section1数据源增加item时，其实也影响到了section0。单纯刷新section1就会崩溃了。</p><p>对于这种场景，简单的做法是特别处理item个数由0增加至1的情况，调用reloadData进行刷新。但是我个人认为，EmptyCell不应该由这种方式来实现。使用UITableView时，需要保证数据源item和UITableViewCell一一对应。凭空捏造一个EmptyCell不好维护。容易导致<code>NSInternalInconsistencyException</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS的开发中，UITableView是最经常用到的UI组件之一。然而，UITableView却非常容易引起「NSInternalInconsistencyException（数据不一致）」的崩溃。其中，调用reloadSections时，一不留神就会引发崩溃。&lt;/p&gt;
&lt;h3 id=&quot;reloadSections简介&quot;&gt;&lt;a href=&quot;#reloadSections简介&quot; class=&quot;headerlink&quot; title=&quot;reloadSections简介&quot;&gt;&lt;/a&gt;reloadSections简介&lt;/h3&gt;&lt;p&gt;当UITableView的数据源变化时，通常会调用&lt;code&gt;reloadData&lt;/code&gt;或者&lt;code&gt;reloadSections:withRowAnimation:&lt;/code&gt;通知UITableView刷新UI。单从UI角度考虑，两者最大的区别就是&lt;code&gt;reloadData&lt;/code&gt;没有动画。所以，一般为用户体验考虑，我一般使用&lt;code&gt;reloadSections:withRowAnimation:&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;reloadSections引发崩溃&quot;&gt;&lt;a href=&quot;#reloadSections引发崩溃&quot; class=&quot;headerlink&quot; title=&quot;reloadSections引发崩溃&quot;&gt;&lt;/a&gt;reloadSections引发崩溃&lt;/h3&gt;&lt;p&gt;调用&lt;code&gt;reloadSections:withRowAnimation:&lt;/code&gt;方法时，UITableView会校验其他section，如果发现UITableView内记录的某section的row的数量和&lt;code&gt;[dataSource tableView:numberOfRowsInSection]&lt;/code&gt;返回的不一致时，抛出&lt;code&gt;NSInternalInconsistencyException&lt;/code&gt;异常。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="http://jefferyfan.com/categories/Programing/"/>
    
      <category term="iOS" scheme="http://jefferyfan.com/categories/Programing/iOS/"/>
    
    
      <category term="iOS" scheme="http://jefferyfan.com/tags/iOS/"/>
    
      <category term="Objective-C" scheme="http://jefferyfan.com/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>博文介绍（一）《深入理解RunLoop》</title>
    <link href="http://jefferyfan.com/2015/08/02/programing/iOS/blogpost/01DeepInRunLoop//"/>
    <id>http://jefferyfan.com/2015/08/02/programing/iOS/blogpost/01DeepInRunLoop//</id>
    <published>2015-08-02T11:37:43.000Z</published>
    <updated>2019-11-21T14:33:24.040Z</updated>
    
    <content type="html"><![CDATA[<p>阅读博文《深入理解RunLoop》后的整理。<br>博文从RunLoop的底层代码切入，介绍RunLoop的实现原理，并相应的讲解Apple基于RunLoop的开发，例如屏幕触摸，UIGestureRecognizer，performSelector等。</p><p>首先简要的说一下写博文介绍的意义。看完一篇博客之后，尝试用自己的话说出来，是梳理知识的过程。同时，也方便我以后快速review，也给各位一个参考。<br>博文介绍系列尝试用简介明了的话去概括原博文，因此相对来说也不会特别详细，见谅。但是，会将博文中提到的知识点进行罗列，并且会做一些补充。方便查阅。</p><h3 id="博文介绍"><a href="#博文介绍" class="headerlink" title="博文介绍"></a>博文介绍</h3><p>博文来源：<a href="http://www.cocoachina.com/ios/20150601/11970.html" target="_blank" rel="noopener">《深入理解RunLoop》</a></p><h5 id="RunLoop机制"><a href="#RunLoop机制" class="headerlink" title="RunLoop机制"></a>RunLoop机制</h5><p>简单来说，RunLoop实际上是在不停的循环处理事件。在每一个循环中，如果有事件需要响应则立刻响应，无事件响应时则休眠。</p><ul><li><p>RunLoop结构包含有多个Mode。Mode中保存着Source，Observer，Timer。顾名思义，Source是事件来源，分为两类，Source0类型的事件不会主动唤醒休眠的RunLoop，需要外界主动唤醒；Source1类型的事件利用Mach实现，可以唤醒休眠中的RunLoop。Observer是观察者，RunLoop进入不同的阶段时会相应的通知到Observer。Timer则是计时器的事件。</p></li><li><p>RunLoop可以在多个Mode之间切换。切换到特定Mode时，只会处理该Mode下的Source/Observer/Timer。不过，RunLoop中还保存着CommonModeItems，在RunLoop内容发生变化时，RunLoop会把CommonModeItems中的Source/Observer/Timer同步到标记为Common的Mode中。</p></li><li><p>一个线程最多有一个RunLoop。RunLoop在获取的时候创建。新建立的线程如果从来没有获取过RunLoop，则该线程没有对应的RunLoop。</p></li></ul><a id="more"></a><ul><li>RunLoop运行流程。图片引用自<a href="http://www.cocoachina.com/ios/20150601/11970.html" target="_blank" rel="noopener">原博客</a>。<br><img src="http://cc.cocimg.com/api/uploads/20150528/1432798974517485.png" alt="RunLoop运行流程"></li></ul><h5 id="Source1原理"><a href="#Source1原理" class="headerlink" title="Source1原理"></a>Source1原理</h5><p>Source1通过调用mach_msg获取事件消息。获取消息实际上是基于port的的进程间通信。在用户态调用mach_msg实则调用了mach_msg_trap陷阱，切换到内核态。内核态的mach_msg才进行处理。如果没有需要响应的消息，内核将用户线程置于等待状态；如果有需要响应的消息，则将消息返回，控制权给回用户线程。</p><h5 id="RunLoop实现的功能"><a href="#RunLoop实现的功能" class="headerlink" title="RunLoop实现的功能"></a>RunLoop实现的功能</h5><p>以下列举了苹果用RunLoop实现的功能。详细的介绍可以看回原博文。</p><ul><li>AutoReleasePool</li><li>锁屏/触摸等事件响应</li><li>手势识别</li><li>界面更新</li><li>定时器</li><li>performSelector</li><li>GCD</li><li>网络请求</li></ul><h3 id="引用资源"><a href="#引用资源" class="headerlink" title="引用资源"></a>引用资源</h3><ul><li><a href="http://segmentfault.com/a/1190000002400329" target="_blank" rel="noopener">进程间通信 (OSX/iOS)</a></li><li><a href="http://opensource.apple.com/" target="_blank" rel="noopener">苹果开源代码</a></li><li><a href="http://iphonedevwiki.net/index.php/IOHIDFamily" target="_blank" rel="noopener">IOHIDFamily</a></li></ul><h3 id="Mac-OS-X-背后的故事"><a href="#Mac-OS-X-背后的故事" class="headerlink" title="Mac OS X 背后的故事"></a>Mac OS X 背后的故事</h3><ul><li><a href="http://www.programmer.com.cn/6727/" target="_blank" rel="noopener">Mac OS X 背后的故事（一）力挽狂澜的Ellen Hancock</a></li><li><a href="http://www.programmer.com.cn/6617/" target="_blank" rel="noopener">Mac OS X 背后的故事（二）Linus Torvalds的短视</a></li><li><a href="http://www.programmer.com.cn/8121/" target="_blank" rel="noopener">Mac OS X 背后的故事（三）Mach之父Avie Tevanian</a></li><li><a href="http://www.programmer.com.cn/7784/" target="_blank" rel="noopener">Mac OS X 背后的故事（四）政客的跨界</a></li><li><a href="http://www.programmer.com.cn/9234/" target="_blank" rel="noopener">Mac OS X 背后的故事（五）Jean-Marie Hullot的Interface Builder神话</a></li><li><a href="http://www.programmer.com.cn/9016/" target="_blank" rel="noopener">Mac OS X 背后的故事（六）Cordell Ratzlaff 引发的 Aqua 革命（上）</a></li><li><a href="http://www.programmer.com.cn/9528/" target="_blank" rel="noopener">Mac OS X 背后的故事（七）Cordell Ratzlaff 引发的 Aqua 革命（下）</a></li><li><a href="http://www.programmer.com.cn/9436/" target="_blank" rel="noopener">Mac OS X 背后的故事（八）三好学生Chris Lattner的LLVM编译工具链</a></li><li><a href="http://www.programmer.com.cn/10071/" target="_blank" rel="noopener">Mac OS X 背后的故事（九）半导体的丰收（上）</a></li><li><a href="http://www.programmer.com.cn/11557/" target="_blank" rel="noopener">Mac OS X 背后的故事（十）半导体的丰收（中）</a></li><li><a href="http://www.programmer.com.cn/11615/" target="_blank" rel="noopener">Mac OS X 背后的故事（十一）半导体的丰收（下）</a></li><li><a href="http://www.programmer.com.cn/13200/" target="_blank" rel="noopener">Mac OS X 背后的故事（十二）Mac OS X文件系统的来龙去脉（上）</a></li><li><a href="http://www.programmer.com.cn/13478/" target="_blank" rel="noopener">Mac OS X 背后的故事（十三）Mac OS X文件系统的来龙去脉（下）</a></li><li><a href="http://www.programmer.com.cn/14703/" target="_blank" rel="noopener">Mac OS X 背后的故事（十四）向Intel迁移！（上）</a></li><li><a href="http://www.programmer.com.cn/15687/" target="_blank" rel="noopener">Mac OS X 背后的故事（十五）向Intel迁移！（中）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阅读博文《深入理解RunLoop》后的整理。&lt;br&gt;博文从RunLoop的底层代码切入，介绍RunLoop的实现原理，并相应的讲解Apple基于RunLoop的开发，例如屏幕触摸，UIGestureRecognizer，performSelector等。&lt;/p&gt;
&lt;p&gt;首先简要的说一下写博文介绍的意义。看完一篇博客之后，尝试用自己的话说出来，是梳理知识的过程。同时，也方便我以后快速review，也给各位一个参考。&lt;br&gt;博文介绍系列尝试用简介明了的话去概括原博文，因此相对来说也不会特别详细，见谅。但是，会将博文中提到的知识点进行罗列，并且会做一些补充。方便查阅。&lt;/p&gt;
&lt;h3 id=&quot;博文介绍&quot;&gt;&lt;a href=&quot;#博文介绍&quot; class=&quot;headerlink&quot; title=&quot;博文介绍&quot;&gt;&lt;/a&gt;博文介绍&lt;/h3&gt;&lt;p&gt;博文来源：&lt;a href=&quot;http://www.cocoachina.com/ios/20150601/11970.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《深入理解RunLoop》&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;RunLoop机制&quot;&gt;&lt;a href=&quot;#RunLoop机制&quot; class=&quot;headerlink&quot; title=&quot;RunLoop机制&quot;&gt;&lt;/a&gt;RunLoop机制&lt;/h5&gt;&lt;p&gt;简单来说，RunLoop实际上是在不停的循环处理事件。在每一个循环中，如果有事件需要响应则立刻响应，无事件响应时则休眠。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;RunLoop结构包含有多个Mode。Mode中保存着Source，Observer，Timer。顾名思义，Source是事件来源，分为两类，Source0类型的事件不会主动唤醒休眠的RunLoop，需要外界主动唤醒；Source1类型的事件利用Mach实现，可以唤醒休眠中的RunLoop。Observer是观察者，RunLoop进入不同的阶段时会相应的通知到Observer。Timer则是计时器的事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;RunLoop可以在多个Mode之间切换。切换到特定Mode时，只会处理该Mode下的Source/Observer/Timer。不过，RunLoop中还保存着CommonModeItems，在RunLoop内容发生变化时，RunLoop会把CommonModeItems中的Source/Observer/Timer同步到标记为Common的Mode中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个线程最多有一个RunLoop。RunLoop在获取的时候创建。新建立的线程如果从来没有获取过RunLoop，则该线程没有对应的RunLoop。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Programing" scheme="http://jefferyfan.com/categories/Programing/"/>
    
      <category term="iOS" scheme="http://jefferyfan.com/categories/Programing/iOS/"/>
    
    
      <category term="iOS" scheme="http://jefferyfan.com/tags/iOS/"/>
    
  </entry>
  
</feed>
